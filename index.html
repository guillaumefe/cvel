
<!DOCTYPE html>
<html lang="en">
<head>
<style>
    /* Reset and root variables */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
        --bg-primary: #0f172a;
        --bg-secondary: #1e293b;
        --accent: #3b82f6;
        --text-primary: #f8fafc;
        --text-secondary: #94a3b8;
        --success: #22c55e;
        --warning: #f59e0b;
        --danger: #ef4444;
        --card-bg: rgba(30, 41, 59, 0.5);
    }

    /* Body and layout */
    body {
        background: var(--bg-primary);
        color: var(--text-primary);
        font-family: 'Inter', sans-serif;
        min-height: 100vh;
        line-height: 1.6;
    }
    .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
    }

    /* Navbar */
    .navbar {
        background: var(--bg-secondary);
        padding: 1rem 2rem;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 2rem;
    }
    .logo {
        font-size: 1.5rem;
        font-weight: 700;
        background: linear-gradient(45deg, var(--accent), var(--success));
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
    }

    /* Card */
    .card {
        background: var(--card-bg);
        border-radius: 1rem;
        padding: 1.5rem;
        margin-bottom: 1.5rem;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s;
    }
    .card:hover { transform: translateY(-2px); }

    /* Input */
    .input, input[type="text"], textarea {
        width: 100%;
        padding: 0.75rem 1rem;
        background: var(--bg-secondary);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 0.5rem;
        color: var(--text-primary);
        font-size: 1rem;
        margin-bottom: 1rem;
        transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }
    .input:focus, input[type="text"]:focus, textarea:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 5px rgba(59, 130, 246, 0.5);
    }

    /* Buttons */
    .btn {
        padding: 0.75rem 1.5rem;
        border: none;
        border-radius: 0.5rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 1rem;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
    }
    .btn-primary { background: var(--accent); color: white; }
    .btn-secondary {
        background: var(--bg-secondary);
        color: var(--text-primary);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    .btn-success { background: var(--success); color: white; }
    .btn-warning { background: var(--warning); color: white; }
    .btn-danger { background: var(--danger); color: white; }
    .btn:hover { transform: translateY(-1px); filter: brightness(110%); }

    /* Grid */
    .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 1.5rem;
    }

    /* Tabs */
    .tab-group {
        display: flex;
        gap: 1rem;
        margin-bottom: 2rem;
    }
    .tab {
        padding: 0.5rem 1rem;
        cursor: pointer;
        border-radius: 0.5rem;
        transition: all 0.2s;
        color: var(--text-secondary);
    }
    .tab.active { background: var(--accent); color: white; }

    /* Terminal */
    .terminal {
        background: #1a1a1a;
        padding: 1rem;
        border-radius: 0.5rem;
        font-family: 'Fira Code', monospace;
        line-height: 1.4;
        margin: 1rem 0;
        max-height: 400px;
        overflow-y: auto;
    }
    .terminal-line { display: flex; gap: 1rem; padding: 0.25rem 0; }
    .terminal-prompt { color: var(--success); }
    .terminal-output { color: var(--text-secondary); white-space: pre-wrap; }

    /* Badges */
    .badge {
        padding: 0.25rem 0.5rem;
        border-radius: 9999px;
        font-size: 0.875rem;
        font-weight: 500;
    }
    .badge-blue { background: rgba(59, 130, 246, 0.1); color: var(--accent); }
    .badge-green { background: rgba(34, 197, 94, 0.1); color: var(--success); }
    .badge-warning { background: rgba(245, 158, 11, 0.1); color: var(--warning); }

    /* Animations */
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    .animate-in { animation: fadeIn 0.3s ease-out; }

    /* Modal */
    .modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
    }
    .modal-content {
        width: 90%;
        max-width: 800px;
        height: 90vh;
        max-height: 600px;
        overflow-y: auto; /* Ajoute le d√©filement vertical */
        display: flex;
        flex-direction: column;
        background: var(--bg-secondary);
        padding: 1rem;
        border-radius: 1rem;
    }

    /* Miscellaneous */
    .flex { display: flex; align-items: center; gap: 1rem; }
    .progress-container {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 10px;
        background: #3a3f47;
        border-radius: 5px;
        overflow: hidden;
        height: 12px;
        margin: 0.5rem 0;
    }
    .generation-log, .log-entry {
        background: var(--bg-secondary);
        border-radius: 0.5rem;
        padding: 1rem;
        margin-top: 1rem;
        max-height: 300px;
        overflow-y: auto;
    }
    .log-entry.error { background: rgba(239, 68, 68, 0.2); }
    .log-entry.warning { background: rgba(245, 158, 11, 0.2); }
    .log-entry.success { background: rgba(34, 197, 94, 0.2); }
    .log-entry.info { background: rgba(59, 130, 246, 0.2); }
    .analogy-game {
        background-color: #f5f5f5;
        text-align: center;
        padding: 50px;
    }
    .technical-game {
        background-color: #1a1d25;
        color: #fff;
        font-family: monospace;
        text-align: center;
        padding-top: 50px;
    }
</style>

</head>
<body>
<!-- Inclusion des biblioth√®ques React, ReactDOM et Babel -->
<script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>



    <nav class="navbar">
        <div class="logo">VulnLearner</div>
        <div class="flex">
            <button onclick="app.showAIConfig()" class="btn btn-secondary" id="ai-config-btn">
                <span class="badge badge-warning">IA: Non configur√©e</span>
            </button>
            <span class="badge badge-blue">Mode Apprentissage</span>
            <button class="btn btn-secondary">Documentation</button>
        </div>
    </nav>
    <div class="container">
        <div class="tab-group">
            <div class="tab" onclick="app.setTab('cr√©ation')">Cr√©ation</div>
            <div class="tab" onclick="app.setTab('biblioth√®que')">Biblioth√®que</div>
            <div class="tab" onclick="app.setTab('progression')">Progression</div>
        </div>
        <div id="tab-content"></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.10/purify.min.js"></script>
    
<script>

    class CodeValidator {
        static validateGameCode(code) {
            const requiredElements = {
                style: new RegExp('<style[^>]*>[\\s\\S]*?<\\/style>', 'i'),
                javascript: new RegExp('<script[^>]*>[\\s\\S]*?<\\/script>', 'i'),
                htmlStructure: new RegExp('<body[^>]*>[\\s\\S]*?<\\/body>', 'i'),
                cdn: new RegExp('https:\\/\\/cdnjs\\.cloudflare\\.com', 'i')
            };
    
            const validation = {
                isValid: true,
                missing: [],
                messages: []
            };
    
            // V√©rification de chaque √©l√©ment requis
            for (const [element, regex] of Object.entries(requiredElements)) {
                if (!regex.test(code)) {
                    validation.isValid = false;
                    validation.missing.push(element);
                    validation.messages.push(`${element} manquant dans le code`);
                }
            }
    
            // V√©rification du fond blanc et texte noir par d√©faut
            if (!code.includes('background-color: #ffffff') && !code.includes('background: #fff') && !code.includes('background: white')) {
                validation.messages.push('Fond blanc manquant');
            }
            if (!code.includes('color: #000000') && !code.includes('color: black')) {
                validation.messages.push('Texte noir manquant');
            }
    
            // V√©rification de la pr√©sence d'au moins une fonction JavaScript
            const jsContent = code.match(new RegExp('<script[^>]*>([\\s\\S]*?)<\\/script>', 'i'));
            if (jsContent && jsContent[1]) {
                if (!jsContent[1].includes('function')) {
                    validation.messages.push('Aucune fonction JavaScript d√©finie');
                }
            }
    
            return validation;
        }
    }

    class VulnLearnerApp {
        constructor() {
            this.storage = window.localStorage;
            this.maxRetries = 3;
            this.retryDelay = 1000;
            
            this.initializeModels();
            this.initializeState();
            this.initializeStorage();
            this.initializeEventListeners();
            this.loadCurrentTab();
            this.updateAIBadge();
            this.addUsageStyles();
            this.initializeLogger();
        }
        


        async callAI(prompt) {
            const provider = this.state.aiConfig.provider;
            if (provider === 'none') {
                throw new Error('Please configure an AI provider in the settings.');
            }
        
            try {
                if (provider === 'claude') {
                    return await this.callClaude(prompt);
                } else if (provider === 'openai') {
                    return await this.callChatGPT(prompt);
                } else {
                    throw new Error('Unsupported AI provider selected.');
                }
            } catch (error) {
                console.error('Error in callAI:', error);
                throw error;
            }
        }
        
        // Mise √† jour du HTML de la navbar pour inclure l'ID correct
        updateNavbar() {
            const navbar = document.querySelector('.navbar');
            if (navbar) {
                navbar.innerHTML = `
                    <div class="logo">VulnLearner</div>
                    <div class="flex">
                        <button class="btn btn-secondary" id="ai-config-btn">
                            <span class="badge badge-warning">IA: Non configur√©e</span>
                        </button>
                        <span class="badge badge-blue">Mode Apprentissage</span>
                        <button class="btn btn-secondary">Documentation</button>
                    </div>
                `;
                // R√©attacher l'√©couteur apr√®s la mise √† jour
                const aiConfigBtn = document.getElementById('ai-config-btn');
                if (aiConfigBtn) {
                    aiConfigBtn.onclick = () => this.showAIConfig();
                }
            }
        }
        
        async resumeGeneration() {
            const generationData = JSON.parse(this.storage.getItem('generationInProgress'));
            if (!generationData) {
                console.log('Aucune g√©n√©ration en cours √† reprendre');
                return;
            }
    
            const { name, cve, description } = generationData;
            console.log('Reprise de la g√©n√©ration pour:', name);
    
            const terminal = document.querySelector('.terminal');
            if (terminal) {
                this.appendToTerminal(terminal, 'Reprise de la g√©n√©ration...', 'info');
            }
    
            try {
                // G√©n√©ration du sc√©nario analogique
                this.log('Reprise de la g√©n√©ration du sc√©nario analogique...', 'info');
                let analogyResponse = await this.callAI(this.buildAnalogyPrompt(name, cve, description));
                analogyResponse = await this.validateAndRetryGeneration(analogyResponse);
                this.log('Sc√©nario analogique g√©n√©r√©.', 'success');
    
                // G√©n√©ration du sc√©nario technique
                this.log('Reprise de la g√©n√©ration du sc√©nario technique...', 'info');
                let technicalResponse = await this.callAI(this.buildTechnicalPrompt(name, cve, description));
                technicalResponse = await this.validateAndRetryGeneration(technicalResponse);
                this.log('Sc√©nario technique g√©n√©r√©.', 'success');
    
                // Cr√©er et sauvegarder la vuln√©rabilit√©
                const vulnerability = {
                    id: Date.now().toString(),
                    name,
                    cve,
                    description,
                    analogyCode: analogyResponse,
                    technicalCode: technicalResponse,
                    created: new Date().toISOString()
                };
    
                // Sauvegarder dans localStorage
                const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
                vulnerabilities.push(vulnerability);
                localStorage.setItem('vulnerabilities', JSON.stringify(vulnerabilities));
    
                // Injecter les jeux et mettre √† jour l'interface
                await this.injectGamesIntoWall(vulnerability);
                this.log('G√©n√©ration reprise termin√©e avec succ√®s!', 'success');
                this.showNotification('Vuln√©rabilit√© cr√©√©e!', 'success');
                this.loadCurrentTab();
    
            } catch (error) {
                this.log(`Erreur lors de la reprise: ${error.message}`, 'error');
                this.showNotification(error.message, 'danger');
            } finally {
                // Nettoyer l'√©tat de g√©n√©ration
                this.storage.removeItem('generationInProgress');
            }
        }
        
        // M√©thode sp√©cifique pour les √©couteurs globaux
        initializeEventListeners() {
            // Attendre que le DOM soit charg√©
            document.addEventListener('DOMContentLoaded', () => {
                // Configuration IA
                const aiConfigBtn = document.getElementById('ai-config-btn');
                if (aiConfigBtn) {
                    aiConfigBtn.onclick = () => this.showAIConfig();
                }

                // Gestion des onglets
                const tabs = document.querySelectorAll('.tab');
                tabs.forEach(tab => {
                    tab.onclick = (e) => {
                        tabs.forEach(t => t.classList.remove('active'));
                        e.target.classList.add('active');
                        this.setTab(e.target.textContent.toLowerCase());
                    };
                });
            });
        }
        
        // M√©thode sp√©cifique pour initialiser les √©couteurs de formulaire
        initializeFormListeners() {
            const nameInput = document.querySelector('input[placeholder="Nom de la vuln√©rabilit√©"]');
            const cveInput = document.querySelector('input[placeholder="Identifiant CVE (optionnel)"]');
            const descTextarea = document.querySelector('textarea[placeholder="Description d√©taill√©e"]');
            
            if (!nameInput || !cveInput || !descTextarea) {
                console.warn("Form elements not found. Skipping initialization.");
                return;
            }
        
            nameInput.value = this.state.formData.name;
            cveInput.value = this.state.formData.cve;
            descTextarea.value = this.state.formData.description;
        
            const updateStorage = () => {
                this.state.formData = {
                    name: nameInput.value,
                    cve: cveInput.value,
                    description: descTextarea.value
                };
                this.storage.setItem('formData', JSON.stringify(this.state.formData));
            };
        
            nameInput.addEventListener('input', updateStorage);
            cveInput.addEventListener('input', updateStorage);
            descTextarea.addEventListener('input', updateStorage);
        }

       // M√©thode d'initialisation du logger
        initializeLogger() {
            this.logContainer = document.createElement('div');
            this.logContainer.className = 'generation-log';
            const terminal = document.querySelector('.terminal');
            if (terminal) {
                terminal.appendChild(this.logContainer);
            }
        }

        loadCurrentTab() {
            const contentContainer = document.querySelector('#tab-content');
            contentContainer.innerHTML = '';

            // Mettre √† jour les classes actives des onglets
            document.querySelectorAll('.tab').forEach(tab => {
                const tabName = tab.textContent.toLowerCase();
                if (tabName === this.state.currentTab) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });

            let content;
            switch (this.state.currentTab) {
                case 'cr√©ation':
                    content = `
                        <div class="card animate-in">
                            <h2>Nouvelle Vuln√©rabilit√©</h2>
                            <div style="margin-top: 1rem;">
                                <div>
                                    <input type="text" placeholder="Nom de la vuln√©rabilit√©" value="${this.state.formData.name}">
                                    <input type="text" placeholder="Identifiant CVE (optionnel)" value="${this.state.formData.cve}">
                                    <textarea rows="4" placeholder="Description d√©taill√©e">${this.state.formData.description}</textarea>
                                    <button class="btn btn-primary" onclick="app.generateVulnerability()">G√©n√©rer les Simulations</button>
                                </div>
                                <div class="generation-box">
                                    <div class="generation-progress">
                                        <div class="progress-bar-container">
                                            <div class="progress-bar"></div>
                                        </div>
                                        <div class="generation-logs">
                                            <div class="logs-title">Logs de g√©n√©ration</div>
                                            <div class="logs-container">
                                                <div class="logs-content"></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>`;
                    break;
                case 'biblioth√®que':
                    content = this.getLibraryContent();
                    break;
                case 'progression':
                    content = this.getProgressionContent();
                    break;
                default:
                    content = '';
            }

            contentContainer.innerHTML = content;

            if (this.state.currentTab === 'cr√©ation') {
                this.initializeFormListeners();
                this.addGenerationStyles();
            }
        }


        addSectionStyles() {
            const styles = document.createElement('style');
            styles.textContent = `
                .vulnerabilities-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                    gap: 1.5rem;
                    padding: 1rem 0;
                }

                .vulnerability-card {
                    background: var(--card-bg);
                    border-radius: 0.5rem;
                    padding: 1.5rem;
                    border: 1px solid rgba(255, 255, 255, 0.1);
                }

                .vuln-header {
                    display: flex;
                    align-items: center;
                    gap: 1rem;
                    margin-bottom: 1rem;
                }

                .vuln-description {
                    color: var(--text-secondary);
                    margin-bottom: 1.5rem;
                }

                .vuln-actions {
                    display: flex;
                    gap: 0.5rem;
                    flex-wrap: wrap;
                }

                .progress-stats {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                    gap: 1.5rem;
                    margin: 1.5rem 0;
                }

                .stat-card {
                    background: var(--card-bg);
                    padding: 1.5rem;
                    border-radius: 0.5rem;
                    text-align: center;
                }

                .stat-card h3 {
                    font-size: 2rem;
                    color: var(--accent);
                    margin-bottom: 0.5rem;
                }

                .stat-card p {
                    color: var(--text-secondary);
                }

                .activities-list {
                    background: var(--bg-secondary);
                    border-radius: 0.5rem;
                    padding: 1rem;
                    margin-top: 1rem;
                }

                .activity-item {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 0.75rem;
                    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                }

                .activity-item:last-child {
                    border-bottom: none;
                }

                .activity-score {
                    color: var(--success);
                    font-weight: 500;
                }

                .activity-mode {
                    color: var(--text-secondary);
                }
            `;
            document.head.appendChild(styles);
        }

    addGenerationStyles() {
        const styles = document.createElement('style');
        styles.textContent = `
            .generation-box {
                margin-top: 1.5rem;
                background: var(--bg-secondary);
                border-radius: 0.5rem;
                overflow: hidden;
            }

            .generation-progress {
                padding: 1rem;
            }

            .progress-bar-container {
                width: 100%;
                height: 6px;
                background: var(--bg-primary);
                border-radius: 3px;
                overflow: hidden;
            }

            .progress-bar {
                height: 100%;
                width: 0;
                background: var(--accent);
                transition: width 0.3s ease;
            }

            .generation-logs {
                margin-top: 1rem;
            }

            .logs-title {
                font-weight: 500;
                color: var(--text-primary);
                margin-bottom: 0.5rem;
            }

            .logs-container {
                background: var(--bg-primary);
                border-radius: 0.5rem;
                padding: 1rem;
                min-height: 200px;
                max-height: 400px;
                overflow-y: auto;
            }

            .logs-content {
                font-family: 'Fira Code', monospace;
                font-size: 0.9rem;
                line-height: 1.5;
            }

            .log-entry {
                display: flex;
                align-items: baseline;
                gap: 0.5rem;
                padding: 0.25rem 0;
            }

            .log-entry .log-time {
                color: var(--text-secondary);
                font-size: 0.8rem;
            }

            .log-entry.info .log-message { color: var(--text-primary); }
            .log-entry.success .log-message { color: var(--success); }
            .log-entry.warning .log-message { color: var(--warning); }
            .log-entry.error .log-message { color: var(--danger); }

            .log-entry.error {
                background: rgba(239, 68, 68, 0.1);
                padding: 0.5rem;
                border-radius: 0.25rem;
                margin: 0.25rem 0;
            }
        `;
        document.head.appendChild(styles);
    }

    log(message, type = 'info') {
        const logsContent = document.querySelector('.logs-content');
        if (!logsContent) return;

        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        entry.innerHTML = `
            <span class="log-time">[${new Date().toLocaleTimeString()}]</span>
            <span class="log-message">${message}</span>
        `;
        
        logsContent.appendChild(entry);
        logsContent.scrollTop = logsContent.scrollHeight;

        // Mise √† jour de la barre de progression
        this.updateProgress(message);
        
        // Log console pour debug
        console.log(`${type.toUpperCase()}: ${message}`);
    }

    updateProgress(message) {
        const progressBar = document.querySelector('.progress-bar');
        if (!progressBar) return;

        const steps = {
            'D√©but de la g√©n√©ration': 10,
            'G√©n√©ration du sc√©nario analogique': 25,
            'Sc√©nario analogique valid√©': 50,
            'G√©n√©ration du sc√©nario technique': 65,
            'Sc√©nario technique valid√©': 90,
            'Vuln√©rabilit√© sauvegard√©e': 100
        };

        for (const [step, value] of Object.entries(steps)) {
            if (message.includes(step)) {
                progressBar.style.width = `${value}%`;
                break;
            }
        }
    }
        
ensureBaseStyles(code) {
    // V√©rifie si une balise style existe d√©j√†
    const hasStyle = /<style[^>]*>[\s\S]*?<\/style>/i.test(code);
    const baseStyles = `
        <style>
            body {
                background-color: #ffffff !important;
                color: #000000 !important;
                margin: 0;
                padding: 20px;
                font-family: Arial, sans-serif;
            }
            .game-container {
                max-width: 800px;
                margin: 0 auto;
            }
            /* Forcer les couleurs pour les √©l√©ments de texte communs */
            p, h1, h2, h3, h4, h5, h6, span, div {
                color: #000000 !important;
            }
            /* Conserver les couleurs sp√©cifiques pour les boutons et √©l√©ments d'interface */
            button, .btn, .button {
                color: inherit;
            }
        </style>
    `;

    if (!hasStyle) {
        // Ajoute les styles dans le head
        code = code.replace('</head>', `${baseStyles}</head>`);
    } else {
        // Injecte les styles de base au d√©but des styles existants
        code = code.replace(/<style[^>]*>/i, match => `${match}
            body {
                background-color: #ffffff !important;
                color: #000000 !important;
            }
            p, h1, h2, h3, h4, h5, h6, span, div {
                color: #000000 !important;
            }
            button, .btn, .button {
                color: inherit;
            }
        `);
    }

    return code;
}


async validateAndRetryGeneration(code, retryCount = 0) {
    const validation = CodeValidator.validateGameCode(code);
    
    if (!validation.isValid && retryCount < this.maxRetries) {
        this.log(`Validation √©chou√©e: ${validation.messages.join(', ')}`, 'warning');
        this.log(`Tentative ${retryCount + 1}/${this.maxRetries} de r√©g√©n√©ration...`, 'info');
        
        await new Promise(resolve => setTimeout(resolve, this.retryDelay));
        
        let correctionPrompt = `Le code g√©n√©r√© n√©cessite les corrections suivantes:
        ${validation.messages.map(msg => `- ${msg}`).join('\n')}
        
        RAPPEL DES CONTRAINTES OBLIGATOIRES :
        1. Le code DOIT contenir :
           - CSS dans une balise <style>
           - HTML dans le <body>
           - JavaScript dans une balise <script>
        2. Style par d√©faut OBLIGATOIRE :
           - background-color: #ffffff
           - color: #000000
        3. Au moins une fonction JavaScript
        4. Un CDN de cdnjs.cloudflare.com
        
        R√©g√©n√®re le code complet en respectant TOUTES ces contraintes.`;

        return this.callAI(correctionPrompt)
            .then(newCode => this.validateAndRetryGeneration(newCode, retryCount + 1));
    }
    
    if (!validation.isValid) {
        // Si toujours invalide apr√®s les retries, on force les styles de base
        code = this.ensureBaseStyles(code);
        this.log('Styles de base forc√©s sur le code.', 'warning');
    }
    
    return code;
}



        setTab(tabName) {
            this.state.currentTab = tabName;
            this.storage.setItem('currentTab', tabName);
            this.loadCurrentTab();
        }

        initializeModels() {
            this.AI_MODELS = {
                claude: {
                    models: {
                        'claude-3-opus-20240229': { maxTokens: 200000, costPer1kTokens: { input: 0.015, output: 0.075 }, description: 'Plus puissant et pr√©cis, meilleur raisonnement' },
                        'claude-3-sonnet-20240229': { maxTokens: 200000, costPer1kTokens: { input: 0.003, output: 0.015 }, description: 'Excellent rapport qualit√©/prix' },
                        'claude-2.1': { maxTokens: 100000, costPer1kTokens: { input: 0.008, output: 0.024 }, description: 'Mod√®le stable et √©prouv√©' },
                        'claude-instant-1.2': { maxTokens: 100000, costPer1kTokens: { input: 0.0008, output: 0.0024 }, description: 'Rapide et √©conomique' }
                    }
                },
                openai: {
                    models: {
                        'gpt-4': { maxTokens: 8192, costPer1kTokens: { input: 0.03, output: 0.06 }, description: 'Plus pr√©cis, meilleur pour les t√¢ches complexes' },
                        'gpt-4-turbo-preview': { maxTokens: 128000, costPer1kTokens: { input: 0.01, output: 0.03 }, description: 'Version preview de GPT-4, plus rapide' },
                        'gpt-3.5-turbo': { maxTokens: 4096, costPer1kTokens: { input: 0.0015, output: 0.002 }, description: 'Bon rapport qualit√©/prix, rapide' },
                        'gpt-3.5-turbo-16k': { maxTokens: 16384, costPer1kTokens: { input: 0.003, output: 0.004 }, description: 'GPT-3.5 avec contexte √©tendu' }
                    }
                }
            };
        }

        getDefaultConfig() {
            if (!this.AI_MODELS || !this.AI_MODELS.claude || !this.AI_MODELS.openai) {
                return {
                    provider: 'none',
                    apiKey: '',
                    endpoint: '',
                    maxCost: 0,
                    retryDelay: 1000,
                    maxRetries: 3,
                    enabledModels: { claude: [], openai: [] },
                    modelOrder: { claude: [], openai: [] },
                    preferredModel: ''
                };
            }
            return {
                provider: 'none',
                apiKey: '',
                endpoint: '',
                maxCost: 0,
                retryDelay: 1000,
                maxRetries: 3,
                enabledModels: {
                    claude: Object.keys(this.AI_MODELS.claude.models).slice(0, 2),
                    openai: Object.keys(this.AI_MODELS.openai.models).slice(0, 2)
                },
                modelOrder: {
                    claude: Object.keys(this.AI_MODELS.claude.models),
                    openai: Object.keys(this.AI_MODELS.openai.models)
                },
                preferredModel: ''
            };
        }

        initializeState() {
            var defaultConfig = this.getDefaultConfig();
            var savedConfig = JSON.parse(this.storage.getItem('aiConfig')) || {};
            this.state = {
                currentTab: this.storage.getItem('currentTab') || 'cr√©ation',
                formData: JSON.parse(this.storage.getItem('formData')) || { name: '', cve: '', description: '' },
                aiConfig: Object.assign({}, defaultConfig, savedConfig, {
                    enabledModels: Object.assign({}, defaultConfig.enabledModels, savedConfig.enabledModels || {}),
                    modelOrder: Object.assign({}, defaultConfig.modelOrder, savedConfig.modelOrder || {}),
                    preferredModel: savedConfig.preferredModel || defaultConfig.preferredModel
                })
            };
            this.storage.setItem('aiConfig', JSON.stringify(this.state.aiConfig));
        }

        getUsageStatsHTML() {
            var stats = JSON.parse(this.storage.getItem('usageStats') || '{}');
            var provider = this.state.aiConfig.provider;
            if (provider === 'none' || !stats[provider]) {
                return '<p>Aucune statistique disponible</p>';
            }
            var usageRows = Object.entries(stats[provider]).map((entry) => {
                var model = entry[0];
                var data = entry[1];
                return '<div class="usage-row">' +
                    '<div class="model-name">' + model + '</div>' +
                    '<div class="usage-details">' +
                        '<span>Appels: ' + data.calls + '</span>' +
                        '<span>Tokens: ' + data.tokens.toLocaleString() + '</span>' +
                        '<span>Co√ªt: $' + data.cost.toFixed(4) + '</span>' +
                    '</div>' +
                '</div>';
            }).join('');
            return '<div class="usage-table">' + usageRows + '<div class="usage-total"><strong>Total: $' + this.calculateTotalCost(stats[provider]).toFixed(4) + '</strong></div></div>';
        }

        calculateTotalCost(providerStats) {
            return Object.values(providerStats).reduce((total, data) => total + (data.cost || 0), 0);
        }

        updateUsageStats(provider, model, inputTokens, outputTokens) {
            var stats = JSON.parse(this.storage.getItem('usageStats') || '{}');
            if (!stats[provider]) stats[provider] = {};
            if (!stats[provider][model]) {
                stats[provider][model] = { calls: 0, tokens: 0, cost: 0 };
            }
            var modelInfo = this.AI_MODELS[provider].models[model];
            var inputCost = (inputTokens / 1000) * modelInfo.costPer1kTokens.input;
            var outputCost = (outputTokens / 1000) * modelInfo.costPer1kTokens.output;
            stats[provider][model].calls += 1;
            stats[provider][model].tokens += (inputTokens + outputTokens);
            stats[provider][model].cost += (inputCost + outputCost);
            this.storage.setItem('usageStats', JSON.stringify(stats));
            this.updateUsageDisplay();
        }

        updateUsageDisplay() {
            var usageStats = document.getElementById('usage-stats');
            if (usageStats) {
                usageStats.innerHTML = this.getUsageStatsHTML();
            }
        }

        resetUsageStats() {
            if (confirm('Voulez-vous vraiment r√©initialiser toutes les statistiques d\'utilisation ?')) {
                this.storage.setItem('usageStats', JSON.stringify({}));
                this.updateUsageDisplay();
                this.showNotification('Statistiques r√©initialis√©es', 'success');
            }
        }

        addUsageStyles() {
            var styles = document.createElement('style');
            styles.textContent = `
                .usage-table { margin-top: 1rem; }
                .usage-row { display: flex; justify-content: space-between; padding: 0.5rem; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
                .usage-details { display: flex; gap: 1rem; }
                .usage-total { margin-top: 1rem; text-align: right; color: var(--accent); }
                .model-name { font-weight: 500; }
            `;
            document.head.appendChild(styles);
        }

        getLibraryContent() {
            const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
            console.log("Displaying vulnerabilities:", vulnerabilities);
        
            if (!vulnerabilities.length) {
                return '<div class="card animate-in"><h2>Biblioth√®que vide</h2><p style="color: var(--text-secondary);">Cr√©ez votre premi√®re vuln√©rabilit√© dans l\'onglet Cr√©ation.</p></div>';
            }
        
            return vulnerabilities.map((vuln) => {
                const cveBadge = vuln.cve ? `<span class="badge badge-blue">${vuln.cve}</span>` : '';
                return `
                    <div class="card animate-in">
                        <div style="margin-bottom: 1rem;">
                            <h3 style="margin-bottom: 0.5rem;">${vuln.name}</h3>
                            ${cveBadge}
                        </div>
                        <p style="color: var(--text-secondary); margin-bottom: 1rem;">${vuln.description}</p>
                        <div class="flex">
                            <button class="btn btn-primary" onclick="app.showGame('${vuln.id}', 'analogy')">Mode Histoire</button>
                            <button class="btn btn-warning" onclick="app.showGame('${vuln.id}', 'technical')">Mode Technique</button>
                            <button class="btn btn-danger" onclick="app.deleteVulnerability('${vuln.id}')">Supprimer</button>
                        </div>
                    </div>`;
            }).join('');
        }

        createWall() {
            const existingWall = document.querySelector('#wall');
            if (!existingWall) {
                const wall = document.createElement('div');
                wall.id = 'wall';
                wall.className = 'grid';
                document.querySelector('.container').appendChild(wall);
            }
        }

        appendToTerminal(terminal, text, type) {
            const line = document.createElement('div');
            line.className = 'terminal-line';
            
            if (type === 'output') {
                line.innerHTML = `<span class="terminal-output">${text}</span>`;
            } else {
                line.innerHTML = `<span class="terminal-prompt">$</span><span class="terminal-output ${type}">${text}</span>`;
            }
            
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
        }

        showNotification(message, type) {
            var notification = document.createElement('div');
            notification.className = 'card animate-in';
            notification.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 1000; background: var(--' + type + '); padding: 1rem; color: ' + (type === 'danger' || type === 'warning' ? 'white' : 'black') + '; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);';
            notification.textContent = message;
            document.body.appendChild(notification);
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        getProgressionContent() {
            var progress = JSON.parse(this.storage.getItem('userProgress'));
            var vulnerabilities = JSON.parse(this.storage.getItem('vulnerabilities'));
            return '<div class="card animate-in"><h2>Votre Progression</h2><div style="margin-top: 1rem;"><div class="flex" style="margin-bottom: 1rem;"><div><h3 style="color: var(--success);">' + progress.totalScore + '</h3><p style="color: var(--text-secondary);">Score total</p></div><div><h3 style="color: var(--accent);">' + progress.completedGames.length + '</h3><p style="color: var(--text-secondary);">Sc√©narios termin√©s</p></div><div><h3 style="color: var(--warning);">' + vulnerabilities.length + '</h3><p style="color: var(--text-secondary);">Vuln√©rabilit√©s cr√©√©es</p></div></div><h3 style="margin: 1rem 0;">Derni√®res activit√©s</h3>' + this.getRecentActivities() + '</div></div>';
        }

        getRecentActivities() {
            var progress = JSON.parse(this.storage.getItem('userProgress'));
            if (!progress.completedGames.length) {
                return '<p style="color: var(--text-secondary);">Aucune activit√© pour le moment</p>';
            }
            return '<div class="terminal" style="background: var(--bg-secondary);">' + progress.completedGames.sort((a, b) => b.timestamp - a.timestamp).slice(0, 5).map((game) => '<div class="terminal-line"><span class="terminal-prompt">></span><span class="terminal-output">' + game.name + ' - Mode ' + game.mode + ' <span style="color: var(--success);">+' + game.score + ' pts</span></span></div>').join('') + '</div>';
        }

        deleteVulnerability(id) {
            if (confirm('√ätes-vous s√ªr de vouloir supprimer cette vuln√©rabilit√© ?')) {
                let vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
                console.log("Vulnerabilities before deletion:", vulnerabilities);
                vulnerabilities = vulnerabilities.filter((vuln) => vuln.id.toString() !== id.toString());
                console.log("Vulnerabilities after filtering:", vulnerabilities);
                localStorage.setItem('vulnerabilities', JSON.stringify(vulnerabilities));
                const updatedVulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities'));
                console.log("Vulnerabilities in storage after deletion:", updatedVulnerabilities);
                this.showNotification('Vuln√©rabilit√© supprim√©e', 'success');
                this.loadCurrentTab();
            }
        }

        buildAnalogyPrompt(name, cve, description) {
            return `
            Cr√©e le code HTML CSS JS complet et enti√®rement fonctionnel pour une seule page (index.html) qui explique la vuln√©rabilit√© ${name} ${cve ? `(${cve})` : ''} de mani√®re analogique.

            CONTRAINTES TECHNIQUES OBLIGATOIRES :
            1. Le code DOIT contenir ces trois parties, CHACUNE EST OBLIGATOIRE :
               - CSS dans une balise <style>
               - HTML dans le <body>
               - JavaScript dans une balise <script>
            2. Style par d√©faut OBLIGATOIRE :
               - background-color: #ffffff (fond blanc)
               - color: #000000 (texte noir)
            3. Au moins une fonction JavaScript interactive DOIT √™tre d√©finie
            4. Inclure au moins un CDN
            5. La page DOIT √™tre autonome et fonctionner sans d√©pendances externes (hors CDN)

            D√âTAILS DU JEU :
            - Cr√©er une m√©taphore simple et ludique (ex: infiltration d'un b√¢timent pour expliquer une injection)
            - Interface claire avec des boutons "Continuer" pour chaque √©tape
            - Feedback visuel pour chaque action (animations, messages)
            - Le joueur doit comprendre intuitivement la vuln√©rabilit√© ${name} √† la fin

            RETOURNE LE CODE COMPLET sans omission ni commentaire avec toutes les parties (HTML, CSS, JavaScript). N'OMETS AUCUNE PARTIE.`;
        }

        buildTechnicalPrompt(name, cve, description) {
            return `
            Cr√©e le code HTML CSS JS complet et enti√®rement fonctionnel pour une seule page (index.html) qui simule techniquement l'exploitation de la vuln√©rabilit√© ${name} ${cve ? `(${cve})` : ''}.

            CONTRAINTES TECHNIQUES OBLIGATOIRES :
            1. Le code DOIT contenir ces trois parties, CHACUNE EST OBLIGATOIRE :
               - CSS dans une balise <style>
               - HTML dans le <body>
               - JavaScript dans une balise <script>
            2. Style par d√©faut OBLIGATOIRE :
               - background-color: #ffffff (fond blanc)
               - color: #000000 (texte noir)
            3. Au moins une fonction JavaScript interactive DOIT √™tre d√©finie
            4. Inclure au moins un CDN
            5. La page DOIT √™tre autonome et fonctionner sans d√©pendances externes (hors CDN)

            D√âTAILS DU JEU :
            - Interface type terminal avec commandes interactives
            - Chaque √©tape doit simuler une vraie commande (nmap, sqlmap, etc.)
            - Messages clairs expliquant les actions techniques
            - Le joueur doit comprendre techniquement l'exploitation √† la fin

            RETOURNE LE CODE COMPLET sans omission ni commentaire avec toutes les parties (HTML, CSS, JavaScript). N'OMETS AUCUNE PARTIE.`;
        }




showGame(vulnId, mode) {
    const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
    const vuln = vulnerabilities.find(v => v.id === vulnId.toString());
    if (!vuln) {
        this.showNotification('Vuln√©rabilit√© non trouv√©e.', 'danger');
        return;
    }

    const gameContent = mode === 'analogy' ? vuln.analogyCode : vuln.technicalCode;
    const currentPrompt = mode === 'analogy' ? vuln.analogyPrompt : vuln.technicalPrompt; // AJOUT√â

    if (!gameContent) {
        this.showNotification('Le jeu s√©lectionn√© est manquant.', 'danger');
        return;
    }

    // Assurer le fond blanc et le texte noir
    const wrappedContent = `
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <style>
                /* Style de base forc√© */
                html, body {
                    background-color: #ffffff !important;
                    color: #000000 !important;
                    margin: 0 !important;
                    padding: 20px !important;
                    min-height: 100vh !important;
                    font-family: Arial, sans-serif !important;
                }
                /* Forcer les couleurs pour les √©l√©ments de texte communs */
                p, h1, h2, h3, h4, h5, h6, span, div {
                    color: #000000 !important;
                }
                /* Conserver les couleurs sp√©cifiques pour les boutons et √©l√©ments d'interface */
                button, .btn, .button {
                    color: inherit;
                }
            </style>
            ${gameContent.match(/<style[^>]*>[\s\S]*?<\/style>/gi) || ''}
        </head>
        <body>
            ${gameContent.match(/<body[^>]*>([\s\S]*?)<\/body>/i)?.[1] || gameContent}
            ${gameContent.match(/<script[^>]*>[\s\S]*?<\/script>/gi) || ''}
        </body>
        </html>`;

    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
        <div class="modal-content card">
            <h2>${vuln.name} - ${mode === 'analogy' ? 'Mode Histoire' : 'Mode Technique'}</h2>
            <div class="game-container">
                <iframe 
                    srcdoc="${DOMPurify.sanitize(wrappedContent)}"
                    sandbox="allow-scripts allow-same-origin"
                    style="background: #ffffff !important; width: 100%; height: 100%; border: none;"
                    frameborder="0">
                </iframe>
            </div>
            <div class="flex" style="margin-top: 1rem; gap: 1rem;">
                <button class="btn btn-primary" onclick="app.reloadGame('${vuln.id}', '${mode}')">
                    üîÑ Recharger
                </button>
                <button class="btn btn-danger" onclick="this.closest('.modal').remove()">Fermer</button>
            </div>
        </div>`;

    document.body.appendChild(modal);

    // AJOUT√â : Forcer les styles apr√®s le chargement de l'iframe
    const iframe = modal.querySelector('iframe');
    iframe.onload = () => {
        const iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
        const style = iframeDocument.createElement('style');
        style.textContent = `
            body {
                background-color: #ffffff !important;
                color: #000000 !important;
            }
            p, h1, h2, h3, h4, h5, h6, span, div {
                color: #000000 !important;
            }
            button, .btn, .button {
                color: inherit;
            }
        `;
        iframeDocument.head.appendChild(style);
    };
}






        injectGamesIntoWall(vulnerability) {
            const wallElement = document.querySelector('#wall');
            if (!wallElement) {
                this.showNotification("L'√©l√©ment du wall n'a pas √©t√© trouv√©.", 'danger');
                return;
            }

            wallElement.innerHTML += `
                <div class="vulnerability-card" id="${vulnerability.id}">
                    <h3>${vulnerability.name} (CVE: ${vulnerability.cve})</h3>
                    <div class="game-container">
                        <h4>Mode Histoire</h4>
                        <iframe srcdoc="${DOMPurify.sanitize(vulnerability.analogyCode)}" sandbox="allow-scripts" width="100%" height="300px"></iframe>
                    </div>
                    <div class="game-container">
                        <h4>Mode Technique</h4>
                        <iframe srcdoc="${DOMPurify.sanitize(vulnerability.technicalCode)}" sandbox="allow-scripts" width="100%" height="300px"></iframe>
                    </div>
                </div>`;
        }


        async retrySpecificMode(mode, name, cve, description, maxRetries = 3) {
            let retryCount = 0;
            while (retryCount < maxRetries) {
                this.log(`Tentative ${retryCount + 1}/${maxRetries} pour le mode ${mode}...`, 'info');
                
                try {
                    const prompt = mode === 'analogy' 
                        ? this.buildAnalogyPrompt(name, cve, description)
                        : this.buildTechnicalPrompt(name, cve, description);
                    
                    let response = await this.callAI(prompt);
                    response = await this.validateAndRetryGeneration(response);
                    
                    const validation = this.validateGameContent(response);
                    if (validation.isValid) {
                        this.log(`Mode ${mode} g√©n√©r√© avec succ√®s.`, 'success');
                        return { isValid: true, code: response };
                    }
                } catch (error) {
                    this.log(`Erreur lors de la tentative ${retryCount + 1}: ${error.message}`, 'error');
                }
                
                retryCount++;
                await new Promise(resolve => setTimeout(resolve, this.retryDelay));
            }
            
            return { isValid: false, code: null };
        }
        
saveAIConfig() {
    const provider = document.getElementById('ai-provider').value;
    const gameType = document.getElementById('game-type').value; // Nouvel √©l√©ment
    const apiKey = document.getElementById('ai-key').value;
    const endpoint = document.getElementById('ai-endpoint').value;
    const maxCost = parseFloat(document.getElementById('max-cost').value);
    const retryDelay = parseInt(document.getElementById('retry-delay').value);
    const maxRetries = parseInt(document.getElementById('max-retries').value);

    this.state.aiConfig = {
        ...this.state.aiConfig,
        provider,
        gameType, // Sauvegarder le type de jeu
        apiKey,
        endpoint,
        maxCost,
        retryDelay,
        maxRetries
    };

    this.storage.setItem('aiConfig', JSON.stringify(this.state.aiConfig));
    this.updateAIBadge();
    this.showNotification('Configuration IA sauvegard√©e', 'success');
}


validateGameContent(code) {
    // Validation de base
    const validation = CodeValidator.validateGameCode(code);

    // V√©rifications suppl√©mentaires
    const hasInteractiveElements = code.includes('onclick') || 
                                code.includes('addEventListener') || 
                                code.includes('input') ||
                                code.includes('button') ||
                                code.includes('function '); // S'assurer qu'au moins une fonction est d√©finie
    
    const hasProperStructure = code.includes('<!DOCTYPE html>') &&
                             code.includes('<html') &&
                             code.includes('<head') &&
                             code.includes('<body');

    // Log des validations
    this.log(`Validation - √âl√©ments interactifs: ${hasInteractiveElements}`, 'info');
    this.log(`Validation - Structure HTML: ${hasProperStructure}`, 'info');

    return {
        isValid: validation.isValid && hasInteractiveElements && hasProperStructure,
        messages: [
            ...validation.messages,
            !hasInteractiveElements ? 'Pas d\'√©l√©ments interactifs trouv√©s' : null,
            !hasProperStructure ? 'Structure HTML incorrecte' : null
        ].filter(Boolean)
    };
}



        async updateExistingVulnerability(vulnId, mode, code) {
            const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
            const index = vulnerabilities.findIndex(v => v.id === vulnId);
            
            if (index !== -1) {
                if (mode === 'analogy') {
                    vulnerabilities[index].analogyCode = code;
                } else {
                    vulnerabilities[index].technicalCode = code;
                }
                
                localStorage.setItem('vulnerabilities', JSON.stringify(vulnerabilities));
                this.log(`Mode ${mode} mis √† jour pour la vuln√©rabilit√© ${vulnId}`, 'success');
                return true;
            }
            
            return false;
        }

        async callClaude(prompt) {
            const selectedModel = this.state.aiConfig.preferredModel;
            const apiKey = this.state.aiConfig.apiKey;
        
            if (!apiKey) {
                throw new Error('API Key for Claude is missing. Please configure it in the settings.');
            }
        
            const url = this.state.aiConfig.endpoint || 'https://api.anthropic.com/v1/messages';
        
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true' 
                },
                body: JSON.stringify({
                    model: selectedModel,
                    messages: [{ role: 'user', content: prompt }],
                    max_tokens: 4096
                })
            });
        
            if (!response.ok) {
                throw new Error(`Claude API Error: ${await response.text()}`);
            }
        
            const result = await response.json();
            return result.content[0].text.trim();
        }
        
        async callChatGPT(prompt) {
            const selectedModel = this.state.aiConfig.preferredModel;
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.state.aiConfig.apiKey}`
                },
                body: JSON.stringify({
                    model: selectedModel,
                    messages: [{ role: 'user', content: prompt }],
                    temperature: 0.7
                })
            });
        
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.message || 'OpenAI API Error');
            }
        
            const data = await response.json();
            return data.choices[0].message.content;
        }

        initializeFormListeners() {
            const nameInput = document.querySelector('input[placeholder="Nom de la vuln√©rabilit√©"]');
            const cveInput = document.querySelector('input[placeholder="Identifiant CVE (optionnel)"]');
            const descTextarea = document.querySelector('textarea[placeholder="Description d√©taill√©e"]');
            
            if (!nameInput || !cveInput || !descTextarea) {
                console.warn("Form elements not found. Skipping initialization.");
                return;
            }
        
            nameInput.value = this.state.formData.name;
            cveInput.value = this.state.formData.cve;
            descTextarea.value = this.state.formData.description;
        
            const updateStorage = () => {
                this.state.formData = {
                    name: nameInput.value,
                    cve: cveInput.value,
                    description: descTextarea.value
                };
                this.storage.setItem('formData', JSON.stringify(this.state.formData));
            };
        
            nameInput.addEventListener('input', updateStorage);
            cveInput.addEventListener('input', updateStorage);
            descTextarea.addEventListener('input', updateStorage);
        }

        initializeStorage() {
            if (!this.storage.getItem('vulnerabilities')) {
                this.storage.setItem('vulnerabilities', JSON.stringify([]));
            }
            if (!this.storage.getItem('userProgress')) {
                this.storage.setItem('userProgress', JSON.stringify({ completedGames: [], totalScore: 0 }));
            }
            if (!this.storage.getItem('formData')) {
                this.storage.setItem('formData', JSON.stringify({ name: '', cve: '', description: '' }));
            }
        }

        updateAIBadge() {
            var badge = document.querySelector('#ai-config-btn .badge');
            if (this.state.aiConfig.provider !== 'none') {
                badge.className = 'badge badge-blue';
                badge.textContent = 'IA: ' + this.state.aiConfig.provider;
            } else {
                badge.className = 'badge badge-warning';
                badge.textContent = 'IA: Non configur√©e';
            }
        }

        completeGame(vulnId, mode) {
            var vulnerabilities = JSON.parse(this.storage.getItem('vulnerabilities'));
            var vuln = vulnerabilities.find((v) => v.id === vulnId);
            if (!vuln) return;
            var progress = JSON.parse(this.storage.getItem('userProgress'));
            var score = mode === 'analogy' ? 10 : 20;
            progress.completedGames.push({ id: vulnId, name: vuln.name, mode: mode, score: score, timestamp: Date.now() });
            progress.totalScore += score;
            this.storage.setItem('userProgress', JSON.stringify(progress));
            this.showNotification('+' + score + ' points gagn√©s !', 'success');
            document.querySelector('.modal').remove();
            this.loadCurrentTab();
        }
      
      
// Ajout des configurations Firebase dans l'interface IA
        showAIConfig() {
            console.log('Ouverture de la configuration IA'); // Debug
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'flex'; // Forcer l'affichage
            modal.innerHTML = `
                <div class="modal-content card" style="width: 90%; max-width: 800px;">
                    <h2>Configuration</h2>
                    <div class="tab-group" style="margin: 1rem 0;">
                        <div class="config-tab active" onclick="app.switchConfigTab(this, 'ai')">IA</div>
                        <div class="config-tab" onclick="app.switchConfigTab(this, 'firebase')">Firebase</div>
                    </div>
                    
                    <div id="ai-config" class="config-section">
                        <div class="provider-select">
                            <select class="input" id="ai-provider" onchange="app.updateProviderConfig(this.value)">
                                <option value="none" ${this.state.aiConfig.provider === 'none' ? 'selected' : ''}>
                                    Choisir un provider
                                </option>
                                <option value="claude" ${this.state.aiConfig.provider === 'claude' ? 'selected' : ''}>
                                    Claude (Anthropic)
                                </option>
                                <option value="openai" ${this.state.aiConfig.provider === 'openai' ? 'selected' : ''}>
                                    ChatGPT (OpenAI)
                                </option>
                            </select>
                        </div>

                        <div id="model-config" class="provider-config" style="margin-top: 1rem;">
                            ${this.generateModelConfigHTML()}
                        </div>

                        <input type="password" class="input" id="ai-key" 
                            placeholder="Cl√© API" value="${this.state.aiConfig.apiKey || ''}">
                        <input type="text" class="input" id="ai-endpoint" 
                            placeholder="Endpoint (optionnel)" value="${this.state.aiConfig.endpoint || ''}">

                        <div class="global-settings">
                            <h3>Param√®tres globaux</h3>
                            <div class="input-group">
                                <label>Budget maximum par requ√™te (USD)</label>
                                <input type="number" class="input" id="max-cost"
                                    value="${this.state.aiConfig.maxCost || 0.60}"
                                    step="0.01" min="0">
                            </div>
                            <div class="input-group">
                                <label>D√©lai entre tentatives (ms)</label>
                                <input type="number" class="input" id="retry-delay"
                                    value="${this.state.aiConfig.retryDelay || 1000}"
                                    min="500">
                            </div>
                            <div class="input-group">
                                <label>Nombre maximum de tentatives</label>
                                <input type="number" class="input" id="max-retries"
                                    value="${this.state.aiConfig.maxRetries || 3}"
                                    min="1" max="5">
                            </div>
                        </div>

                        <div class="usage-stats">
                            <h3>Statistiques d'utilisation</h3>
                            <div id="usage-stats">
                                ${this.getUsageStatsHTML()}
                            </div>
                        </div>
                    </div>

                    <div id="firebase-config" class="config-section" style="display: none;">
                        <!-- Contenu Firebase -->
                    </div>

                    <div class="flex" style="margin-top: 1rem; gap: 1rem;">
                        <button class="btn btn-primary" onclick="app.saveAIConfig()">Sauvegarder</button>
                        <button class="btn btn-secondary" onclick="app.testConnection()">Tester la connexion</button>
                        <button class="btn btn-warning" onclick="app.resetUsageStats()">
                            R√©initialiser les statistiques
                        </button>
                        <button class="btn btn-danger" onclick="this.closest('.modal').remove()">Fermer</button>
                    </div>
                </div>
            `;

            // Ajouter les styles
            this.addAIConfigStyles();
            
            // Ajouter la modal au body
            document.body.appendChild(modal);
            
            // Initialiser les gestionnaires d'√©v√©nements
            this.initializeConfigHandlers();
        }
        
initializeConfigHandlers() {
    // Get the AI config elements from the DOM
    const providerSelect = document.getElementById('ai-provider-select');
    const apiKeyInput = document.getElementById('ai-api-key');
    const endpointInput = document.getElementById('ai-endpoint');
    const saveButton = document.getElementById('save-ai-config');
    const testConnectionButton = document.getElementById('test-ai-connection');

    // Check if each element exists before trying to set its properties
    if (providerSelect) {
        providerSelect.value = this.state.aiConfig.provider;
        providerSelect.onchange = () => {
            this.state.aiConfig.provider = providerSelect.value;
        };
    }

    if (apiKeyInput) {
        apiKeyInput.value = this.state.aiConfig.apiKey;
        apiKeyInput.oninput = () => {
            this.state.aiConfig.apiKey = apiKeyInput.value;
        };
    }

    if (endpointInput) {
        endpointInput.value = this.state.aiConfig.endpoint;
        endpointInput.oninput = () => {
            this.state.aiConfig.endpoint = endpointInput.value;
        };
    }

    if (saveButton) {
        saveButton.onclick = () => {
            const newConfig = {
                provider: providerSelect ? providerSelect.value : '',
                apiKey: apiKeyInput ? apiKeyInput.value : '',
                endpoint: endpointInput ? endpointInput.value : ''
            };

            this.saveAIConfig(newConfig);
            this.showNotification('Configuration sauvegard√©e avec succ√®s.', 'success');
        };
    }

    if (testConnectionButton) {
        testConnectionButton.onclick = () => {
            this.testConnection();
        };
    }
}


        
async testConnection() {
    const provider = this.state.aiConfig.provider;
    const apiKey = this.state.aiConfig.apiKey;
    const endpoint = this.state.aiConfig.endpoint || '';

    if (provider === 'none') {
        this.showNotification('Aucun fournisseur d\'IA configur√©.', 'danger');
        return;
    }

    if (!apiKey) {
        this.showNotification('Cl√© API manquante. Veuillez la configurer dans les param√®tres.', 'danger');
        return;
    }

    this.showNotification('Test de connexion en cours...', 'info');

    try {
        let response;

        if (provider === 'claude') {
            // Appel d'une m√©thode pour tester la connexion avec Claude
            response = await this.callClaude('Bonjour, ceci est un test de connexion.');
        } else if (provider === 'openai') {
            // Appel d'une m√©thode pour tester la connexion avec OpenAI
            response = await this.callChatGPT('Bonjour, ceci est un test de connexion.');
        } else {
            throw new Error('Fournisseur d\'IA non support√©.');
        }

        if (response) {
            this.showNotification('Connexion r√©ussie avec ' + (provider === 'claude' ? 'Claude' : 'OpenAI') + '!', 'success');
        } else {
            throw new Error('R√©ponse vide re√ßue.');
        }
    } catch (error) {
        this.showNotification(`√âchec de la connexion: ${error.message}`, 'danger');
        console.error('Erreur lors du test de connexion:', error);
    }
}



        // Gestion de Firebase
        initializeFirebase() {
            const config = JSON.parse(localStorage.getItem('firebaseConfig'));
            if (!config) return;

            if (!window.firebase) {
                const script = document.createElement('script');
                script.src = 'https://www.gstatic.com/firebasejs/9.x.x/firebase-app.js';
                script.onload = () => {
                    const analyticsScript = document.createElement('script');
                    analyticsScript.src = 'https://www.gstatic.com/firebasejs/9.x.x/firebase-firestore.js';
                    analyticsScript.onload = () => {
                        this.initializeFirebaseApp(config);
                    };
                    document.head.appendChild(analyticsScript);
                };
                document.head.appendChild(script);
            } else {
                this.initializeFirebaseApp(config);
            }
        }

        async initializeFirebaseApp(config) {
            try {
                this.firebaseApp = firebase.initializeApp(config);
                this.db = firebase.firestore();
                console.log('Firebase initialized successfully');
            } catch (error) {
                console.error('Firebase initialization error:', error);
            }
        }
        
    /**
     * M√©thode pour tester la connexion avec le fournisseur d'IA configur√©.
     */



        async saveFirebaseConfig() {
            const config = {
                apiKey: document.getElementById('firebase-apiKey').value,
                authDomain: document.getElementById('firebase-authDomain').value,
                projectId: document.getElementById('firebase-projectId').value,
                storageBucket: document.getElementById('firebase-storageBucket').value,
                messagingSenderId: document.getElementById('firebase-messagingSenderId').value,
                appId: document.getElementById('firebase-appId').value
            };

            localStorage.setItem('firebaseConfig', JSON.stringify(config));
            this.state.firebaseConfig = config;
            this.initializeFirebase();
            this.showNotification('Configuration Firebase sauvegard√©e', 'success');
        }

        async testFirebaseConnection() {
            try {
                if (!this.db) {
                    throw new Error('Firebase n\'est pas initialis√©');
                }
                await this.db.collection('test').add({
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                });
                this.showNotification('Connexion Firebase r√©ussie', 'success');
            } catch (error) {
                this.showNotification('Erreur de connexion Firebase: ' + error.message, 'danger');
            }
        }

        async syncVulnerabilities() {
            if (!this.db) {
                this.showNotification('Firebase n\'est pas configur√©', 'danger');
                return;
            }

            try {
                const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
                
                // Organiser les vuln√©rabilit√©s par mode
                const organizedVulns = {
                    histoire: vulnerabilities.filter(v => v.analogyCode),
                    technique: vulnerabilities.filter(v => v.technicalCode)
                };

                // Mise √† jour de Firebase
                const batch = this.db.batch();
                
                // Collection pour le mode histoire
                for (const vuln of organizedVulns.histoire) {
                    const ref = this.db.collection('vulnerabilites').doc('histoire').collection('jeux').doc(vuln.id);
                    batch.set(ref, {
                        ...vuln,
                        lastSync: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }

                // Collection pour le mode technique
                for (const vuln of organizedVulns.technique) {
                    const ref = this.db.collection('vulnerabilites').doc('technique').collection('jeux').doc(vuln.id);
                    batch.set(ref, {
                        ...vuln,
                        lastSync: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }

                await batch.commit();
                this.showNotification('Synchronisation r√©ussie', 'success');
            } catch (error) {
                this.showNotification('Erreur de synchronisation: ' + error.message, 'danger');
            }
        }

        // Style pour les onglets de configuration
        addConfigStyles() {
            const styles = document.createElement('style');
            styles.textContent = `
                .config-tab {
                    padding: 0.5rem 1rem;
                    cursor: pointer;
                    border-radius: 0.5rem;
                    color: var(--text-secondary);
                    background: var(--bg-secondary);
                    
                }

                .config-tab.active {
                    background: var(--accent);
                }

                .config-section {
                    margin-top: 1rem;
                }
            `;
            document.head.appendChild(styles);
        }

        switchConfigTab(tab, section) {
            // G√©rer l'activation des onglets
            document.querySelectorAll('.config-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');

            // Afficher la section correspondante
            document.querySelectorAll('.config-section').forEach(s => s.style.display = 'none');
            document.getElementById(`${section}-config`).style.display = 'block';
        }
    
    /**
     * G√©n√®re le HTML pour la configuration des mod√®les AI en fonction du fournisseur s√©lectionn√©.
     * @returns {string} - Le HTML g√©n√©r√© pour la s√©lection des mod√®les.
     */
    generateModelConfigHTML() {
        const provider = this.state.aiConfig.provider;

        if (provider === 'none') {
            return '<p>Veuillez s√©lectionner un fournisseur d\'IA pour configurer les mod√®les.</p>';
        }

        const models = this.AI_MODELS[provider].models;
        let html = '<label for="model-select">S√©lectionnez un mod√®le :</label><select class="input" id="model-select">';
        for (const model in models) {
            const selected = this.state.aiConfig.preferredModel === model ? 'selected' : '';
            html += `<option value="${model}" ${selected}>${model} - ${models[model].description}</option>`;
        }
        html += '</select>';

        return html;
    }   

    // M√©thode pour ajouter les styles de configuration AI
    addAIConfigStyles() {
        const style = document.createElement('style');
        style.innerHTML = `
            /* Styles pour le modal de configuration IA */
            .modal {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                background: rgba(0, 0, 0, 0.6);
                z-index: 1000;
            }
            .modal-content {
                background: black;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
                max-width: 600px;
                width: 100%;
            }
            .tab-group {
                display: flex;
                gap: 1rem;
            }
            .config-tab {
                padding: 0.5rem 1rem;
                cursor: pointer;
                border-radius: 0.5rem;
                background: #f0f0f0;
                color : #333;
            }
            .config-tab.active {
                background: #007bff;
                color: white;
            }
            .provider-select select {
                width: 100%;
                padding: 0.5rem;
                margin-top: 1rem;
            }
            .input-group label {
                font-weight: bold;
            }
            .input-group input {
                width: 100%;
                padding: 0.5rem;
                margin-top: 0.5rem;
                margin-bottom: 1rem;
            }
        `;
        document.head.appendChild(style);
    }

async validateAndRetryGeneration(code, mode, retryCount = 0) { // Ajout du param√®tre mode
    const validation = this.validateGameContent(code, mode); // Passer le mode

    if (!validation.isValid && retryCount < this.maxRetries) {
        this.log(`Validation √©chou√©e pour ${mode}: ${validation.messages.join(', ')}`, 'warning');
        this.log(`Tentative ${retryCount + 1}/${this.maxRetries} de r√©g√©n√©ration pour ${mode}...`, 'info');
        
        await new Promise(resolve => setTimeout(resolve, this.retryDelay));
        
        let correctionPrompt = `Le code g√©n√©r√© pour le mode ${mode} n√©cessite les corrections suivantes:
        ${validation.messages.map(msg => `- ${msg}`).join('\n')}
        
        RAPPEL DES CONTRAINTES OBLIGATOIRES :
        1. Le code DOIT contenir ces trois parties, CHACUNE EST OBLIGATOIRE :
           - CSS dans une balise <style>
           - HTML dans le <body>
           - JavaScript dans une balise <script>
        2. Style par d√©faut OBLIGATOIRE :
           - background-color: #ffffff
           - color: #000000
        3. Au moins une fonction JavaScript
        4. Un CDN de cdnjs.cloudflare.com
        
        R√©g√©n√®re le code complet pour le mode ${mode} en respectant TOUTES ces contraintes.`;
        
        return this.callAI(correctionPrompt)
            .then(newCode => this.validateAndRetryGeneration(newCode, mode, retryCount + 1));
    }
    
    if (!validation.isValid) {
        // Si toujours invalide apr√®s les retries, on force les styles de base
        code = this.ensureBaseStyles(code);
        this.log(`Styles de base forc√©s sur le code pour ${mode}.`, 'warning');
    }
    
    return code;
}

        async callAI(prompt) {
            const provider = this.state.aiConfig.provider;
            if (provider === 'none') {
                throw new Error('Please configure an AI provider in the settings.');
            }
        
            try {
                if (provider === 'claude') {
                    return await this.callClaude(prompt);
                } else if (provider === 'openai') {
                    return await this.callChatGPT(prompt);
                } else {
                    throw new Error('Unsupported AI provider selected.');
                }
            } catch (error) {
                console.error('Error in callAI:', error);
                throw error;
            }
        }

    async generateVulnerability() {
        const terminal = document.querySelector('.logs-content');
        if (terminal) terminal.innerHTML = '';

        // R√©initialiser la barre de progression
        const progressBar = document.querySelector('.progress-bar');
        if (progressBar) progressBar.style.width = '0%';

        const { name, cve, description } = this.state.formData;
        if (!name || !description) {
            this.showNotification('Veuillez remplir les champs requis', 'danger');
            return;
        }

        const generateButton = document.querySelector('.btn-primary');
        generateButton.disabled = true;

        try {
            this.log('D√©but de la g√©n√©ration...', 'info');

            // Structure de la vuln√©rabilit√©
            let vulnerability = {
                id: Date.now().toString(),
                name,
                cve,
                description,
                created: new Date().toISOString(),
                analogyPrompt: this.buildAnalogyPrompt(name, cve, description), // AJOUT√â
                technicalPrompt: this.buildTechnicalPrompt(name, cve, description) // AJOUT√â
            };

            // G√©n√©ration du mode analogique (Histoire)
            this.log('G√©n√©ration du sc√©nario analogique...', 'info');
            let analogyResponse = await this.callAI(vulnerability.analogyPrompt);

            // Validation du mode analogique
            analogyResponse = await this.validateAndRetryGeneration(analogyResponse);
            const analogyValidation = this.validateGameContent(analogyResponse);

            if (analogyValidation.isValid) {
                this.log('Sc√©nario analogique valid√© et sauvegard√©.', 'success');
                vulnerability.analogyCode = analogyResponse;
                this.log(`Code Analogy : ${analogyResponse.substring(0, 100)}...`, 'info'); // AJOUT√â
            } else {
                this.log('Sc√©nario analogique invalide, nouvelle tentative...', 'warning');
                const retryAnalogy = await this.retrySpecificMode('analogy', name, cve, description);
                if (retryAnalogy.isValid) {
                    vulnerability.analogyCode = retryAnalogy.code;
                    vulnerability.analogyPrompt = retryAnalogy.prompt; // AJOUT√â
                    this.log('Sc√©nario analogique r√©g√©n√©r√© et valid√©.', 'success');
                    this.log(`Code Analogy R√©g√©n√©r√© : ${retryAnalogy.code.substring(0, 100)}...`, 'info'); // AJOUT√â
                } else {
                    this.log('√âchec de la g√©n√©ration du mode analogique.', 'error');
                    throw new Error('La g√©n√©ration du sc√©nario analogique a √©chou√© apr√®s plusieurs tentatives.');
                }
            }

            // G√©n√©ration du mode technique
            this.log('G√©n√©ration du sc√©nario technique...', 'info');
            let technicalResponse = await this.callAI(vulnerability.technicalPrompt);

            // Validation du mode technique
            technicalResponse = await this.validateAndRetryGeneration(technicalResponse);
            const technicalValidation = this.validateGameContent(technicalResponse);

            if (technicalValidation.isValid) {
                this.log('Sc√©nario technique valid√© et sauvegard√©.', 'success');
                vulnerability.technicalCode = technicalResponse;
                this.log(`Code Technique : ${technicalResponse.substring(0, 100)}...`, 'info'); // AJOUT√â
            } else {
                this.log('Sc√©nario technique invalide, nouvelle tentative...', 'warning');
                const retryTechnical = await this.retrySpecificMode('technical', name, cve, description);
                if (retryTechnical.isValid) {
                    vulnerability.technicalCode = retryTechnical.code;
                    vulnerability.technicalPrompt = retryTechnical.prompt; // AJOUT√â
                    this.log('Sc√©nario technique r√©g√©n√©r√© et valid√©.', 'success');
                    this.log(`Code Technique R√©g√©n√©r√© : ${retryTechnical.code.substring(0, 100)}...`, 'info'); // AJOUT√â
                } else {
                    this.log('√âchec de la g√©n√©ration du mode technique.', 'error');
                    throw new Error('La g√©n√©ration du sc√©nario technique a √©chou√© apr√®s plusieurs tentatives.');
                }
            }

            // V√©rifier que les deux modes sont valides avant de sauvegarder
            if (vulnerability.analogyCode && vulnerability.technicalCode) {
                const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
                vulnerabilities.push(vulnerability);
                localStorage.setItem('vulnerabilities', JSON.stringify(vulnerabilities));

                this.log('Vuln√©rabilit√© sauvegard√©e dans la biblioth√®que.', 'success');
                this.showNotification('Vuln√©rabilit√© cr√©√©e!', 'success');

                // Mise √† jour de la progression √† 100%
                if (progressBar) progressBar.style.width = '100%';

                // Indiquer la fin de la g√©n√©ration
                this.log('G√©n√©ration termin√©e avec succ√®s pour les deux modes.', 'success');
                this.showNotification('G√©n√©ration termin√©e avec succ√®s pour les deux modes.', 'success');

                // Ajout d'un message visuel dans la g√©n√©ration-box
                const generationBox = document.querySelector('.generation-box');
                if (generationBox) {
                    const completionMessage = document.createElement('div');
                    completionMessage.className = 'completion-message';
                    completionMessage.innerHTML = `
                        <p style="color: var(--success); font-weight: bold; margin-top: 1rem;">
                            ‚úÖ G√©n√©ration termin√©e avec succ√®s pour les deux modes.
                        </p>`;
                    generationBox.appendChild(completionMessage);
                }

                this.loadCurrentTab();
            } else {
                throw new Error('La g√©n√©ration n\'a pas pu √™tre compl√©t√©e correctement.');
            }

        } catch (error) {
            this.log(`Erreur: ${error.message}`, 'error');
            this.showNotification(error.message, 'danger');
            // En cas d'erreur, mettre la barre de progression en rouge
            if (progressBar) {
                progressBar.style.backgroundColor = 'var(--danger)';
            }
        } finally {
            generateButton.disabled = false;
            this.storage.removeItem('generationInProgress');
        }
    }

    /**
     * M√©thode pour valider le contenu g√©n√©r√© par l'IA.
     * @param {string} code - Le code g√©n√©r√© par l'IA.
     * @returns {object} - R√©sultat de la validation.
     */
    validateGameContent(code) {
        // Validation de base
        const validation = CodeValidator.validateGameCode(code);

        // V√©rifications suppl√©mentaires
        const hasInteractiveElements = code.includes('onclick') || 
                                        code.includes('addEventListener') || 
                                        code.includes('input') ||
                                        code.includes('button') ||
                                        code.includes('function '); // AJOUT√â : V√©rifier la pr√©sence d'une fonction

        const hasProperStructure = code.includes('<!DOCTYPE html>') &&
                                    code.includes('<html') &&
                                    code.includes('<head') &&
                                    code.includes('<body');

        // Log des validations
        this.log(`Validation - √âl√©ments interactifs: ${hasInteractiveElements}`, 'info');
        this.log(`Validation - Structure HTML: ${hasProperStructure}`, 'info');

        return {
            isValid: validation.isValid && hasInteractiveElements && hasProperStructure,
            messages: [
                ...validation.messages,
                !hasInteractiveElements ? 'Pas d\'√©l√©ments interactifs trouv√©s' : null,
                !hasProperStructure ? 'Structure HTML incorrecte' : null
            ].filter(Boolean)
        };
    }

    /**
     * M√©thode pour valider et r√©essayer la g√©n√©ration du code.
     * @param {string} code - Le code g√©n√©r√© par l'IA.
     * @param {number} retryCount - Le nombre de tentatives effectu√©es.
     * @returns {string} - Le code valid√© ou corrig√©.
     */
    async validateAndRetryGeneration(code, retryCount = 0) {
        const validation = CodeValidator.validateGameCode(code);

        if (!validation.isValid && retryCount < this.maxRetries) {
            this.log(`Validation √©chou√©e: ${validation.messages.join(', ')}`, 'warning');
            this.log(`Tentative ${retryCount + 1}/${this.maxRetries} de r√©g√©n√©ration...`, 'info');

            await new Promise(resolve => setTimeout(resolve, this.retryDelay));

            let correctionPrompt = `Le code g√©n√©r√© n√©cessite les corrections suivantes:
${validation.messages.map(msg => `- ${msg}`).join('\n')}

RAPPEL DES CONTRAINTES OBLIGATOIRES :
1. Le code DOIT contenir :
   - CSS dans une balise <style>
   - HTML dans le <body>
   - JavaScript dans une balise <script>
2. Style par d√©faut OBLIGATOIRE :
   - background-color: #ffffff
   - color: #000000
3. Au moins une fonction JavaScript
4. Un CDN de cdnjs.cloudflare.com

R√©g√©n√®re le code complet en respectant TOUTES ces contraintes.`;

            try {
                const newCode = await this.callAI(correctionPrompt);
                return await this.validateAndRetryGeneration(newCode, retryCount + 1);
            } catch (error) {
                this.log(`Erreur lors de la r√©g√©n√©ration: ${error.message}`, 'error');
                throw error;
            }
        }

        if (!validation.isValid) {
            // Si toujours invalide apr√®s les retries, on force les styles de base
            const correctedCode = this.ensureBaseStyles(code);
            this.log('Styles de base forc√©s sur le code.', 'warning');
            return correctedCode;
        }

        return code;
    }

    /**
     * M√©thode pour forcer les styles de base si le code g√©n√©r√© ne les contient pas.
     * @param {string} code - Le code g√©n√©r√© par l'IA.
     * @returns {string} - Le code avec les styles forc√©s.
     */
    ensureBaseStyles(code) {
        // V√©rifie si une balise style existe d√©j√†
        const hasStyle = /<style[^>]*>[\s\S]*?<\/style>/i.test(code);
        const baseStyles = `
            <style>
                body {
                    background-color: #ffffff !important;
                    color: #000000 !important;
                    margin: 0;
                    padding: 20px;
                    font-family: Arial, sans-serif;
                }
                .game-container {
                    max-width: 800px;
                    margin: 0 auto;
                }
                /* Forcer les couleurs pour les √©l√©ments de texte communs */
                p, h1, h2, h3, h4, h5, h6, span, div {
                    color: #000000 !important;
                }
                /* Conserver les couleurs sp√©cifiques pour les boutons et √©l√©ments d'interface */
                button, .btn, .button {
                    color: inherit;
                }
            </style>
        `;

        if (!hasStyle) {
            // Ajoute les styles dans le head
            code = code.replace('</head>', `${baseStyles}</head>`);
        } else {
            // Injecte les styles de base au d√©but des styles existants
            code = code.replace(/<style[^>]*>/i, match => `${match}
                body {
                    background-color: #ffffff !important;
                    color: #000000 !important;
                }
                p, h1, h2, h3, h4, h5, h6, span, div {
                    color: #000000 !important;
                }
                button, .btn, .button {
                    color: inherit;
                }
            `);
        }

        return code;
    }


async retrySpecificMode(mode, name, cve, description, maxRetries = 3) {
    let retryCount = 0;
    while (retryCount < maxRetries) {
        this.log(`Tentative ${retryCount + 1}/${maxRetries} pour le mode ${mode}...`, 'info');
        
        try {
            const prompt = mode === 'analogy' 
                ? this.buildAnalogyPrompt(name, cve, description)
                : this.buildTechnicalPrompt(name, cve, description);
            
            let response = await this.callAI(prompt);
            response = await this.validateAndRetryGeneration(response);
            
            const validation = this.validateGameContent(response);
            if (validation.isValid) {
                this.log(`Mode ${mode} g√©n√©r√© avec succ√®s.`, 'success');
                return { isValid: true, code: response, prompt: prompt }; // AJOUT√â
            }
        } catch (error) {
            this.log(`Erreur lors de la tentative ${retryCount + 1}: ${error.message}`, 'error');
        }
        
        retryCount++;
        await new Promise(resolve => setTimeout(resolve, this.retryDelay));
    }
    
    return { isValid: false, code: null, prompt: null }; // AJOUT√â
}

    /**
     * M√©thode pour r√©g√©n√©rer un jeu existant en redemandant √† l'IA.
     * @param {string} vulnId - L'ID de la vuln√©rabilit√©.
     * @param {string} mode - Le mode √† r√©g√©n√©rer ('analogy' ou 'technical').
     */
    async reloadGame(vulnId, mode) {
        const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
        const vulnIndex = vulnerabilities.findIndex(v => v.id === vulnId.toString());
        if (vulnIndex === -1) {
            this.showNotification('Vuln√©rabilit√© non trouv√©e.', 'danger');
            return;
        }

        const vuln = vulnerabilities[vulnIndex];
        const currentPrompt = mode === 'analogy' ? vuln.analogyPrompt : vuln.technicalPrompt;
        const promptType = mode === 'analogy' ? 'analogie' : 'technique';

        // Demander √† l'utilisateur de confirmer ou de modifier le prompt
        const userPrompt = prompt(`Veuillez entrer le prompt pour r√©g√©n√©rer le jeu (${promptType}) :`, currentPrompt);

        if (userPrompt === null) {
            // L'utilisateur a annul√©
            return;
        }

        if (userPrompt.trim() === '') {
            this.showNotification('Le prompt ne peut pas √™tre vide.', 'warning');
            return;
        }

        // Mettre √† jour le prompt dans l'objet vuln√©rabilit√©
        vulnerabilities[vulnIndex][`${mode}Prompt`] = userPrompt;
        this.storage.setItem('vulnerabilities', JSON.stringify(vulnerabilities));

        // D√©sactiver le bouton de g√©n√©ration pour √©viter les conflits
        const generateButton = document.querySelector('.btn-primary');
        if (generateButton) {
            generateButton.disabled = true;
        }

        try {
            this.log(`D√©but de la r√©g√©n√©ration du mode ${promptType}...`, 'info');

            // Appeler l'IA avec le nouveau prompt
            const newCode = await this.callAI(userPrompt);

            // Valider le nouveau code
            const validatedCode = await this.validateAndRetryGeneration(newCode);
            const validation = this.validateGameContent(validatedCode);

            if (validation.isValid) {
                this.log(`Mode ${promptType} r√©g√©n√©r√© et valid√©.`, 'success');
                vulnerabilities[vulnIndex][`${mode}Code`] = validatedCode;
                this.storage.setItem('vulnerabilities', JSON.stringify(vulnerabilities));

                // Rafra√Æchir l'iframe avec le nouveau contenu
                const modal = document.querySelector('.modal');
                if (modal) {
                    const iframe = modal.querySelector('iframe');
                    if (iframe) {
                        const wrappedContent = `
                            <!DOCTYPE html>
                            <html>
                            <head>
                                <meta charset="UTF-8">
                                <style>
                                    /* Style de base forc√© */
                                    html, body {
                                        background-color: #ffffff !important;
                                        color: #000000 !important;
                                        margin: 0 !important;
                                        padding: 20px !important;
                                        min-height: 100vh !important;
                                        font-family: Arial, sans-serif !important;
                                    }
                                    /* Forcer les couleurs pour les √©l√©ments de texte communs */
                                    p, h1, h2, h3, h4, h5, h6, span, div {
                                        color: #000000 !important;
                                    }
                                    /* Conserver les couleurs sp√©cifiques pour les boutons et √©l√©ments d'interface */
                                    button, .btn, .button {
                                        color: inherit;
                                    }
                                </style>
                                ${validatedCode.match(/<style[^>]*>[\s\S]*?<\/style>/gi) || ''}
                            </head>
                            <body>
                                ${validatedCode.match(/<body[^>]*>([\s\S]*?)<\/body>/i)?.[1] || validatedCode}
                                ${validatedCode.match(/<script[^>]*>[\s\S]*?<\/script>/gi) || ''}
                            </body>
                            </html>`;

                        iframe.srcdoc = DOMPurify.sanitize(wrappedContent);
                    }
                }

                this.showNotification(`Mode ${promptType} r√©g√©n√©r√© avec succ√®s.`, 'success');
            } else {
                this.log(`Mode ${promptType} invalide apr√®s r√©g√©n√©ration.`, 'error');
                this.showNotification(`La r√©g√©n√©ration du mode ${promptType} a √©chou√©.`, 'danger');
            }

        } catch (error) {
            this.log(`Erreur lors de la r√©g√©n√©ration du mode ${promptType}: ${error.message}`, 'error');
            this.showNotification(`Erreur lors de la r√©g√©n√©ration du mode ${promptType}: ${error.message}`, 'danger');
        } finally {
            // R√©activer le bouton de g√©n√©ration
            if (generateButton) {
                generateButton.disabled = false;
            }
        }
    }
 
        
        // Modification de l'initialisation de l'application
        static initialize() {
            window.addEventListener('DOMContentLoaded', () => {
                window.app = new VulnLearnerApp();
                
                // V√©rifier et reprendre la g√©n√©ration apr√®s l'initialisation compl√®te
                const generationInProgress = window.localStorage.getItem('generationInProgress');
                if (generationInProgress) {
                    console.log('G√©n√©ration en cours d√©tect√©e, tentative de reprise...');
                    window.app.resumeGeneration().catch(error => {
                        console.error('Erreur lors de la reprise de la g√©n√©ration:', error);
                        window.app.showNotification('Erreur lors de la reprise de la g√©n√©ration', 'danger');
                    });
                }
            });
        }
        
    }

    // Initialisation de l'application
    VulnLearnerApp.initialize();
    
</script>
</body>
</html>
