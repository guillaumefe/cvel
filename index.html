<!DOCTYPE html>
<html lang="en">
<head>
<style>
    /* Reset and root variables */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
        --bg-primary: #0f172a;
        --bg-secondary: #1e293b;
        --accent: #3b82f6;
        --text-primary: #f8fafc;
        --text-secondary: #94a3b8;
        --success: #22c55e;
        --warning: #f59e0b;
        --danger: #ef4444;
        --card-bg: rgba(30, 41, 59, 0.5);
    }

    /* Body and layout */
    body {
        background: var(--bg-primary);
        color: var(--text-primary);
        font-family: 'Inter', sans-serif;
        min-height: 100vh;
        line-height: 1.6;
    }
    .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
    }

    /* Navbar */
    .navbar {
        background: var(--bg-secondary);
        padding: 1rem 2rem;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 2rem;
    }
    .logo {
        font-size: 1.5rem;
        font-weight: 700;
        background: linear-gradient(45deg, var(--accent), var(--success));
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
    }

    /* Card */
    .card {
        background: var(--card-bg);
        border-radius: 1rem;
        padding: 1.5rem;
        margin-bottom: 1.5rem;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s;
    }
    .card:hover { transform: translateY(-2px); }

    /* Input */
    .input, input[type="text"], textarea {
        width: 100%;
        padding: 0.75rem 1rem;
        background: var(--bg-secondary);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 0.5rem;
        color: var(--text-primary);
        font-size: 1rem;
        margin-bottom: 1rem;
        transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }
    .input:focus, input[type="text"]:focus, textarea:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 5px rgba(59, 130, 246, 0.5);
    }

    /* Buttons */
    .btn {
        padding: 0.75rem 1.5rem;
        border: none;
        border-radius: 0.5rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 1rem;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
    }
    .btn-primary { background: var(--accent); color: white; }
    .btn-secondary {
        background: var(--bg-secondary);
        color: var(--text-primary);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    .btn-success { background: var(--success); color: white; }
    .btn-warning { background: var(--warning); color: white; }
    .btn-danger { background: var(--danger); color: white; }
    .btn:hover { transform: translateY(-1px); filter: brightness(110%); }

    /* Grid */
    .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 1.5rem;
    }

    /* Tabs */
    .tab-group {
        display: flex;
        gap: 1rem;
        margin-bottom: 2rem;
    }
    .tab {
        padding: 0.5rem 1rem;
        cursor: pointer;
        border-radius: 0.5rem;
        transition: all 0.2s;
        color: var(--text-secondary);
    }
    .tab.active { background: var(--accent); color: white; }

    /* Terminal */
    .terminal {
        background: #1a1a1a;
        padding: 1rem;
        border-radius: 0.5rem;
        font-family: 'Fira Code', monospace;
        line-height: 1.4;
        margin: 1rem 0;
        max-height: 400px;
        overflow-y: auto;
    }
    .terminal-line { display: flex; gap: 1rem; padding: 0.25rem 0; }
    .terminal-prompt { color: var(--success); }
    .terminal-output { color: var(--text-secondary); white-space: pre-wrap; }

    /* Badges */
    .badge {
        padding: 0.25rem 0.5rem;
        border-radius: 9999px;
        font-size: 0.875rem;
        font-weight: 500;
    }
    .badge-blue { background: rgba(59, 130, 246, 0.1); color: var(--accent); }
    .badge-green { background: rgba(34, 197, 94, 0.1); color: var(--success); }
    .badge-warning { background: rgba(245, 158, 11, 0.1); color: var(--warning); }

    /* Animations */
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    .animate-in { animation: fadeIn 0.3s ease-out; }

    /* Modal */
    .modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
    }
    .modal-content {
        width: 90%;
        max-width: 800px;
        height: 90vh;
        max-height: 600px;
        overflow-y: auto; /* Ajoute le défilement vertical */
        display: flex;
        flex-direction: column;
        background: var(--bg-secondary);
        padding: 1rem;
        border-radius: 1rem;
    }

    /* Miscellaneous */
    .flex { display: flex; align-items: center; gap: 1rem; }
    .progress-container {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 10px;
        background: #3a3f47;
        border-radius: 5px;
        overflow: hidden;
        height: 12px;
        margin: 0.5rem 0;
    }
    .generation-log, .log-entry {
        background: var(--bg-secondary);
        border-radius: 0.5rem;
        padding: 1rem;
        margin-top: 1rem;
        max-height: 300px;
        overflow-y: auto;
    }
    .log-entry.error { background: rgba(239, 68, 68, 0.2); }
    .log-entry.warning { background: rgba(245, 158, 11, 0.2); }
    .log-entry.success { background: rgba(34, 197, 94, 0.2); }
    .log-entry.info { background: rgba(59, 130, 246, 0.2); }
    .analogy-game {
        background-color: #f5f5f5;
        text-align: center;
        padding: 50px;
    }
    .technical-game {
        background-color: #1a1d25;
        color: #fff;
        font-family: monospace;
        text-align: center;
        padding-top: 50px;
    }
    iframe {
        width:100%;
        min-height:450px;
    }
</style>
</head>
<body>
<!-- Inclusion des bibliothèques React, ReactDOM et Babel -->
<script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>



    <nav class="navbar">
        <div class="logo">VulnLearner</div>
        <div class="flex">
            <button onclick="app.showAIConfig()" class="btn btn-secondary" id="ai-config-btn">
                <span class="badge badge-warning">IA: Non configurée</span>
            </button>
            <span onclick="app.showLearningConfig()" class="btn badge badge-blue">Mode Apprentissage</span>
            <a href="https://cve.circl.lu/cwe" class="btn btn-secondary" target="_blank" rel="noopener noreferrer">Documentation</a>
        </div>
    </nav>
    <div class="container">
        <div class="tab-group">
            <div class="tab" onclick="app.setTab('création')">Création</div>
            <div class="tab" onclick="app.setTab('bibliothèque')">Bibliothèque</div>
            <div class="tab" onclick="app.setTab('progression')">Progression</div>
        </div>
        <div id="tab-content"></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.10/purify.min.js"></script>
    
<script>

class APIManager {
    constructor(config = {}) {
        this.config = {
            provider: 'none',
            apiKey: '',
            endpoint: '',
            maxCost: 0.60,
            retryDelay: 1000,
            maxRetries: 3,
            ...config
        };
        
        this.AI_MODELS = {
            claude: {
                endpoint: 'https://api.anthropic.com/v1/messages',
                models: {
                    'claude-3-opus-20240229': { 
                        maxTokens: 200000, 
                        costPer1kTokens: { input: 0.015, output: 0.075 }
                    },
                    'claude-3-sonnet-20240229': { 
                        maxTokens: 200000, 
                        costPer1kTokens: { input: 0.003, output: 0.015 }
                    }
                }
            },
            openai: {
                endpoint: 'https://api.openai.com/v1/chat/completions',
                models: {
                    'gpt-4': { 
                        maxTokens: 8192, 
                        costPer1kTokens: { input: 0.03, output: 0.06 }
                    },
                    'gpt-3.5-turbo': { 
                        maxTokens: 4096, 
                        costPer1kTokens: { input: 0.0015, output: 0.002 }
                    }
                }
            }
        };
    }

    validateConfig() {
        const errors = [];
        
        if (!this.config.provider || this.config.provider === 'none') {
            errors.push('No AI provider selected');
        }
        
        if (!this.config.apiKey) {
            errors.push('API key is missing');
        }
        
        if (!this.config.preferredModel) {
            errors.push('No model selected');
        }
        
        if (this.config.provider !== 'none' && !this.AI_MODELS[this.config.provider]) {
            errors.push('Invalid provider selected');
        }
        
        return {
            isValid: errors.length === 0,
            errors
        };
    }

    async callAPI(prompt, retryCount = 0) {
        const validation = this.validateConfig();
        if (!validation.isValid) {
            throw new Error(`Invalid API configuration: ${validation.errors.join(', ')}`);
        }

        try {
            // Ajout d'un délai minimal entre les appels
            await this.enforceRateLimit();
            
            console.log('Making API call...');
            const response = await this.makeAPICall(prompt);
            
            // Ajout d'un délai après chaque appel réussi
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            return this.processResponse(response);
        } catch (error) {
            if (retryCount < this.config.maxRetries) {
                const delay = this.calculateRetryDelay(retryCount);
                console.warn(`API call failed, waiting ${delay}ms before retry ${retryCount + 1}/${this.config.maxRetries}...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                return this.callAPI(prompt, retryCount + 1);
            }
            throw new Error(`API call failed after ${this.config.maxRetries} retries: ${error.message}`);
        }
    }

    // Méthode pour gérer les limites de taux d'appel
    async enforceRateLimit() {
        const now = Date.now();
        const lastCallTime = this.lastAPICallTime || 0;
        const minDelay = 2000; // Délai minimum de 2 secondes entre les appels

        if (now - lastCallTime < minDelay) {
            const waitTime = minDelay - (now - lastCallTime);
            console.log(`Rate limit: Waiting ${waitTime}ms before next call`);
            await new Promise(resolve => setTimeout(resolve, waitTime));
        }

        this.lastAPICallTime = Date.now();
    }

    // Calcul du délai de retry avec backoff exponentiel
    calculateRetryDelay(retryCount) {
        const baseDelay = this.config.retryDelay || 1000;
        return Math.min(baseDelay * Math.pow(2, retryCount), 10000); // Max 10 secondes
    }

    async makeAPICall(prompt) {
        const headers = this.buildHeaders();
        const body = this.buildRequestBody(prompt);
        const endpoint = this.getEndpoint();

        console.log('=== API Call Details ===');
        console.log('Endpoint:', endpoint);
        console.log('Headers:', {...headers, 'x-api-key': '***HIDDEN***'});
        console.log('Request Body:', body);

        const response = await fetch(endpoint, {
            method: 'POST',
            headers,
            body: JSON.stringify(body)
        });

        // Attendre un peu avant de traiter la réponse
        await new Promise(resolve => setTimeout(resolve, 500));

        if (!response.ok) {
            const errorData = await response.json().catch(() => null);
            console.error('API Error Response:', errorData);
            throw new Error(`API Error (${response.status}): ${errorData?.error?.message || response.statusText}`);
        }

        const responseData = await response.json();
        console.log('Response received:', responseData);
        return responseData;
    }

    async makeAPICall(prompt) {
        const headers = this.buildHeaders();
        const body = this.buildRequestBody(prompt);
        const endpoint = this.getEndpoint();

        console.log('=== API Call Details ===');
        console.log('Endpoint:', endpoint);
        console.log('Headers:', {...headers, 'x-api-key': '***HIDDEN***'});
        console.log('Request Body:', body);

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers,
                body: JSON.stringify(body)
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => null);
                console.error('API Error Response:', errorData);
                console.error('Response Status:', response.status);
                console.error('Response Status Text:', response.statusText);
                throw new Error(`API Error (${response.status}): ${errorData?.error?.message || response.statusText}`);
            }

            const responseData = await response.json();
            console.log('=== API Response ===');
            console.log('Raw Response:', responseData);
            
            const processedResponse = this.processResponse(responseData);
            console.log('Processed Response:', processedResponse);
            
            return responseData;
        } catch (error) {
            console.error('=== API Call Failed ===');
            console.error('Error:', error);
            throw error;
        }
    }

    buildHeaders() {
        const commonHeaders = {
            'Content-Type': 'application/json'
        };

        if (this.config.provider === 'claude') {
            return {
                ...commonHeaders,
                'x-api-key': this.config.apiKey,
                'anthropic-version': '2023-06-01'
            };
        }

        if (this.config.provider === 'openai') {
            return {
                ...commonHeaders,
                'Authorization': `Bearer ${this.config.apiKey}`
            };
        }

        return commonHeaders;
    }

    buildRequestBody(prompt) {
        console.log('Building request body for provider:', this.config.provider);
        console.log('Using model:', this.config.preferredModel);
        
        if (this.config.provider === 'claude') {
            const body = {
                model: this.config.preferredModel,
                messages: [{ role: 'user', content: prompt }],
                max_tokens: this.getModelMaxTokens()
            };
            console.log('Claude request body:', body);
            return body;
        }

        if (this.config.provider === 'openai') {
            const body = {
                model: this.config.preferredModel,
                messages: [{ role: 'user', content: prompt }],
                temperature: 0.7
            };
            console.log('OpenAI request body:', body);
            return body;
        }

        throw new Error('Unsupported provider');
    }


    getEndpoint() {
        return this.config.endpoint || this.AI_MODELS[this.config.provider].endpoint;
    }

    getModelMaxTokens() {
        return this.AI_MODELS[this.config.provider].models[this.config.preferredModel].maxTokens;
    }

    processResponse(response) {
        console.log('Processing response for provider:', this.config.provider);
        
        if (this.config.provider === 'claude') {
            const text = response.content[0].text.trim();
            console.log('Claude response text:', text);
            return text;
        }

        if (this.config.provider === 'openai') {
            const text = response.choices[0].message.content.trim();
            console.log('OpenAI response text:', text);
            return text;
        }

        throw new Error('Unsupported provider response format');
    }


    updateConfig(newConfig) {
        this.config = {
            ...this.config,
            ...newConfig
        };
    }

}

    class CodeValidator {
        static validateGameCode(code) {
            const requiredElements = {
                style: new RegExp('<style[^>]*>[\\s\\S]*?<\\/style>', 'i'),
                javascript: new RegExp('<script[^>]*>[\\s\\S]*?<\\/script>', 'i'),
                htmlStructure: new RegExp('<body[^>]*>[\\s\\S]*?<\\/body>', 'i'),
                //cdn: new RegExp('https:\\/\\/cdnjs\\.cloudflare\\.com', 'i')
            };
    
            const validation = {
                isValid: true,
                missing: [],
                messages: []
            };
    
            // Vérification de chaque élément requis
            for (const [element, regex] of Object.entries(requiredElements)) {
                if (!regex.test(code)) {
                    validation.isValid = false;
                    validation.missing.push(element);
                    validation.messages.push(`${element} manquant dans le code`);
                }
            }
    
            // Vérification du fond blanc et texte noir par défaut
            if (!code.includes('background-color: #ffffff') && !code.includes('background: #fff') && !code.includes('background: white')) {
                validation.messages.push('Fond blanc manquant');
            }
            if (!code.includes('color: #000000') && !code.includes('color: black')) {
                validation.messages.push('Texte noir manquant');
            }
    
            // Vérification de la présence d'au moins une fonction JavaScript
            const jsContent = code.match(new RegExp('<script[^>]*>([\\s\\S]*?)<\\/script>', 'i'));
            if (jsContent && jsContent[1]) {
                if (!jsContent[1].includes('function')) {
                    validation.messages.push('Aucune fonction JavaScript définie');
                }
            }
    
            return validation;
        }
    }

    class VulnLearnerApp {
        constructor() {
            this.storage = window.localStorage;
            this.maxRetries = 3;
            this.retryDelay = 1000;
            
            this.initializeModels();
            
            // Initialize apiManager before initializing state
            this.apiManager = new APIManager(JSON.parse(localStorage.getItem('aiConfig')) || {});
            
            this.initializeState();
            this.initializeStorage();
            this.initializeEventListeners();
            this.loadCurrentTab();
            this.updateAIBadge();
            this.addUsageStyles();
            this.initializeLogger();
    
            // Sauvegarder l'état initial
            this.saveState();
        }

        
        // Mise à jour du HTML de la navbar pour inclure l'ID correct
        updateNavbar() {
            const navbar = document.querySelector('.navbar');
            if (navbar) {
                navbar.innerHTML = `
                    <div class="logo">VulnLearner</div>
                    <div class="flex">
                        <button class="btn btn-secondary" id="ai-config-btn">
                            <span class="badge badge-warning">IA: Non configurée</span>
                        </button>
                        <span class="badge badge-blue">Mode Apprentissage</span>
                        <button class="btn btn-secondary">Documentation</button>
                    </div>
                `;
                // Réattacher l'écouteur après la mise à jour
                const aiConfigBtn = document.getElementById('ai-config-btn');
                if (aiConfigBtn) {
                    aiConfigBtn.onclick = () => this.showAIConfig();
                }
            }
        }
        
        async resumeGeneration() {
            const generationData = JSON.parse(this.storage.getItem('generationInProgress'));
            if (!generationData) {
                console.log('Aucune génération en cours à reprendre');
                return;
            }
    
            const { name, cve, description } = generationData;
            console.log('Reprise de la génération pour:', name);
    
            const terminal = document.querySelector('.terminal');
            if (terminal) {
                this.appendToTerminal(terminal, 'Reprise de la génération...', 'info');
            }
    
            try {
                // Génération du scénario analogique
                this.log('Reprise de la génération du scénario analogique...', 'info');
                let analogyResponse = await this.callAI(this.buildAnalogyPrompt(name, cve, description));
                analogyResponse = await this.validateAndRetryGeneration(analogyResponse);
                this.log('Scénario analogique généré.', 'success');
    
                // Génération du scénario technique
                this.log('Reprise de la génération du scénario technique...', 'info');
                let technicalResponse = await this.callAI(this.buildTechnicalPrompt(name, cve, description));
                technicalResponse = await this.validateAndRetryGeneration(technicalResponse);
                this.log('Scénario technique généré.', 'success');
    
                // Créer et sauvegarder la vulnérabilité
                const vulnerability = {
                    id: Date.now().toString(),
                    name,
                    cve,
                    description,
                    analogyCode: analogyResponse,
                    technicalCode: technicalResponse,
                    created: new Date().toISOString()
                };
    
                // Sauvegarder dans localStorage
                const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
                vulnerabilities.push(vulnerability);
                localStorage.setItem('vulnerabilities', JSON.stringify(vulnerabilities));
    
                // Injecter les jeux et mettre à jour l'interface
                await this.injectGamesIntoWall(vulnerability);
                this.log('Génération reprise terminée avec succès!', 'success');
                this.showNotification('Vulnérabilité créée!', 'success');
                this.loadCurrentTab();
    
            } catch (error) {
                this.log(`Erreur lors de la reprise: ${error.message}`, 'error');
                this.showNotification(error.message, 'danger');
            } finally {
                // Nettoyer l'état de génération
                this.storage.removeItem('generationInProgress');
            }
        }
        
        // Méthode spécifique pour les écouteurs globaux
        initializeEventListeners() {
            // Attendre que le DOM soit chargé
            document.addEventListener('DOMContentLoaded', () => {
                // Configuration IA
                const aiConfigBtn = document.getElementById('ai-config-btn');
                if (aiConfigBtn) {
                    aiConfigBtn.onclick = () => this.showAIConfig();
                }

                // Gestion des onglets
                const tabs = document.querySelectorAll('.tab');
                tabs.forEach(tab => {
                    tab.onclick = (e) => {
                        tabs.forEach(t => t.classList.remove('active'));
                        e.target.classList.add('active');
                        this.setTab(e.target.textContent.toLowerCase());
                    };
                });
            });
        }
        
        // Méthode spécifique pour initialiser les écouteurs de formulaire
        initializeFormListeners() {
            const nameInput = document.querySelector('input[placeholder="Nom de la vulnérabilité"]');
            const cveInput = document.querySelector('input[placeholder="Identifiant CVE (optionnel)"]');
            const descTextarea = document.querySelector('textarea[placeholder="Description détaillée"]');
            
            if (!nameInput || !cveInput || !descTextarea) {
                console.warn("Form elements not found. Skipping initialization.");
                return;
            }
        
            nameInput.value = this.state.formData.name;
            cveInput.value = this.state.formData.cve;
            descTextarea.value = this.state.formData.description;
        
            const updateStorage = () => {
                this.state.formData = {
                    name: nameInput.value,
                    cve: cveInput.value,
                    description: descTextarea.value
                };
                this.storage.setItem('formData', JSON.stringify(this.state.formData));
            };
        
            nameInput.addEventListener('input', updateStorage);
            cveInput.addEventListener('input', updateStorage);
            descTextarea.addEventListener('input', updateStorage);
        }

       // Méthode d'initialisation du logger
        initializeLogger() {
            this.logContainer = document.createElement('div');
            this.logContainer.className = 'generation-log';
            const terminal = document.querySelector('.terminal');
            if (terminal) {
                terminal.appendChild(this.logContainer);
            }
        }

        loadCurrentTab() {
            const contentContainer = document.querySelector('#tab-content');
            contentContainer.innerHTML = '';

            // Mettre à jour les classes actives des onglets
            document.querySelectorAll('.tab').forEach(tab => {
                const tabName = tab.textContent.toLowerCase();
                if (tabName === this.state.currentTab) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });

            let content;
            switch (this.state.currentTab) {
                case 'création':
                    content = `
                        <div class="card animate-in">
                            <h2>Nouvelle Vulnérabilité</h2>
                            <div style="margin-top: 1rem;">
                                <div>
                                    <input type="text" placeholder="Nom de la vulnérabilité" value="${this.state.formData.name}">
                                    <input type="text" placeholder="Identifiant CVE (optionnel)" value="${this.state.formData.cve}">
                                    <textarea rows="4" placeholder="Description détaillée">${this.state.formData.description}</textarea>
                                    <button class="btn btn-primary" onclick="app.generateVulnerability()">Générer les Simulations</button>
                                </div>
                                <div class="generation-box">
                                    <div class="generation-progress">
                                        <div class="progress-bar-container">
                                            <div class="progress-bar"></div>
                                        </div>
                                        <div class="generation-logs">
                                            <div class="logs-title">Logs de génération</div>
                                            <div class="logs-container">
                                                <div class="logs-content"></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>`;
                    break;
                case 'bibliothèque':
                    content = this.getLibraryContent();
                    break;
                case 'progression':
                    content = this.getProgressionContent();
                    break;
                default:
                    content = '';
            }

            contentContainer.innerHTML = content;

            if (this.state.currentTab === 'création') {
                this.initializeFormListeners();
                this.addGenerationStyles();
            }
        }


        addSectionStyles() {
            const styles = document.createElement('style');
            styles.textContent = `
                .vulnerabilities-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                    gap: 1.5rem;
                    padding: 1rem 0;
                }

                .vulnerability-card {
                    background: var(--card-bg);
                    border-radius: 0.5rem;
                    padding: 1.5rem;
                    border: 1px solid rgba(255, 255, 255, 0.1);
                }

                .vuln-header {
                    display: flex;
                    align-items: center;
                    gap: 1rem;
                    margin-bottom: 1rem;
                }

                .vuln-description {
                    color: var(--text-secondary);
                    margin-bottom: 1.5rem;
                }

                .vuln-actions {
                    display: flex;
                    gap: 0.5rem;
                    flex-wrap: wrap;
                }

                .progress-stats {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                    gap: 1.5rem;
                    margin: 1.5rem 0;
                }

                .stat-card {
                    background: var(--card-bg);
                    padding: 1.5rem;
                    border-radius: 0.5rem;
                    text-align: center;
                }

                .stat-card h3 {
                    font-size: 2rem;
                    color: var(--accent);
                    margin-bottom: 0.5rem;
                }

                .stat-card p {
                    color: var(--text-secondary);
                }

                .activities-list {
                    background: var(--bg-secondary);
                    border-radius: 0.5rem;
                    padding: 1rem;
                    margin-top: 1rem;
                }

                .activity-item {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 0.75rem;
                    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                }

                .activity-item:last-child {
                    border-bottom: none;
                }

                .activity-score {
                    color: var(--success);
                    font-weight: 500;
                }

                .activity-mode {
                    color: var(--text-secondary);
                }
            `;
            document.head.appendChild(styles);
        }

    addGenerationStyles() {
        const styles = document.createElement('style');
        styles.textContent = `
            .generation-box {
                margin-top: 1.5rem;
                background: var(--bg-secondary);
                border-radius: 0.5rem;
                overflow: hidden;
            }

            .generation-progress {
                padding: 1rem;
            }

            .progress-bar-container {
                width: 100%;
                height: 6px;
                background: var(--bg-primary);
                border-radius: 3px;
                overflow: hidden;
            }

            .progress-bar {
                height: 100%;
                width: 0;
                background: var(--accent);
                transition: width 0.3s ease;
            }

            .generation-logs {
                margin-top: 1rem;
            }

            .logs-title {
                font-weight: 500;
                color: var(--text-primary);
                margin-bottom: 0.5rem;
            }

            .logs-container {
                background: var(--bg-primary);
                border-radius: 0.5rem;
                padding: 1rem;
                min-height: 200px;
                max-height: 400px;
                overflow-y: auto;
            }

            .logs-content {
                font-family: 'Fira Code', monospace;
                font-size: 0.9rem;
                line-height: 1.5;
            }

            .log-entry {
                display: flex;
                align-items: baseline;
                gap: 0.5rem;
                padding: 0.25rem 0;
            }

            .log-entry .log-time {
                color: var(--text-secondary);
                font-size: 0.8rem;
            }

            .log-entry.info .log-message { color: var(--text-primary); }
            .log-entry.success .log-message { color: var(--success); }
            .log-entry.warning .log-message { color: var(--warning); }
            .log-entry.error .log-message { color: var(--danger); }

            .log-entry.error {
                background: rgba(239, 68, 68, 0.1);
                padding: 0.5rem;
                border-radius: 0.25rem;
                margin: 0.25rem 0;
            }
        `;
        document.head.appendChild(styles);
    }

    log(message, type = 'info') {
        const logsContent = document.querySelector('.logs-content');
        if (!logsContent) return;

        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        entry.innerHTML = `
            <span class="log-time">[${new Date().toLocaleTimeString()}]</span>
            <span class="log-message">${message}</span>
        `;
        
        logsContent.appendChild(entry);
        logsContent.scrollTop = logsContent.scrollHeight;

        // Mise à jour de la barre de progression
        this.updateProgress(message);
        
        // Log console pour debug
        console.log(`${type.toUpperCase()}: ${message}`);
    }

    updateProgress(message) {
        const progressBar = document.querySelector('.progress-bar');
        if (!progressBar) return;

        const steps = {
            'Début de la génération': 10,
            'Génération du scénario analogique': 25,
            'Scénario analogique validé': 50,
            'Génération du scénario technique': 65,
            'Scénario technique validé': 90,
            'Vulnérabilité sauvegardée': 100
        };

        for (const [step, value] of Object.entries(steps)) {
            if (message.includes(step)) {
                progressBar.style.width = `${value}%`;
                break;
            }
        }
    }
        
ensureBaseStyles(code) {
    // Vérifie si une balise style existe déjà
    const hasStyle = /<style[^>]*>[\s\S]*?<\/style>/i.test(code);
    const baseStyles = `
        <style>
            body {
                background-color: #ffffff !important;
                color: #000000 !important;
                margin: 0;
                padding: 20px;
                font-family: Arial, sans-serif;
            }
            .game-container {
                max-width: 800px;
                margin: 0 auto;
            }
            /* Forcer les couleurs pour les éléments de texte communs */
            p, h1, h2, h3, h4, h5, h6, span, div {
                color: #000000 !important;
            }
            /* Conserver les couleurs spécifiques pour les boutons et éléments d'interface */
            button, .btn, .button {
                color: inherit;
            }
        </style>
    `;

    if (!hasStyle) {
        // Ajoute les styles dans le head
        code = code.replace('</head>', `${baseStyles}</head>`);
    } else {
        // Injecte les styles de base au début des styles existants
        code = code.replace(/<style[^>]*>/i, match => `${match}
            body {
                background-color: #ffffff !important;
                color: #000000 !important;
            }
            p, h1, h2, h3, h4, h5, h6, span, div {
                color: #000000 !important;
            }
            button, .btn, .button {
                color: inherit;
            }
        `);
    }

    return code;
}


    updateProviderConfig(provider) {
        // Met à jour le fournisseur IA dans l'état
        this.state.aiConfig.provider = provider;
        // Sauvegarde le changement dans le stockage local
        this.storage.setItem('aiConfig', JSON.stringify(this.state.aiConfig));
        
        // Met à jour la sélection des modèles en fonction du nouveau fournisseur
        const modelConfigContainer = document.getElementById('model-config');
        if (modelConfigContainer) {
            modelConfigContainer.innerHTML = this.generateModelConfigHTML();
        }

        this.updateAIBadge();  // Met à jour l'affichage du badge IA
    }



        setTab(tabName) {
            this.state.currentTab = tabName;
            this.storage.setItem('currentTab', tabName);
            this.loadCurrentTab();
        }

        initializeModels() {
            this.AI_MODELS = {
                claude: {
                    models: {
                        'claude-3-opus-20240229': { maxTokens: 200000, costPer1kTokens: { input: 0.015, output: 0.075 }, description: 'Plus puissant et précis, meilleur raisonnement' },
                        'claude-3-sonnet-20240229': { maxTokens: 200000, costPer1kTokens: { input: 0.003, output: 0.015 }, description: 'Excellent rapport qualité/prix' },
                        'claude-2.1': { maxTokens: 100000, costPer1kTokens: { input: 0.008, output: 0.024 }, description: 'Modèle stable et éprouvé' },
                        'claude-instant-1.2': { maxTokens: 100000, costPer1kTokens: { input: 0.0008, output: 0.0024 }, description: 'Rapide et économique' }
                    }
                },
                openai: {
                    models: {
                        'gpt-4': { maxTokens: 8192, costPer1kTokens: { input: 0.03, output: 0.06 }, description: 'Plus précis, meilleur pour les tâches complexes' },
                        'gpt-4-turbo-preview': { maxTokens: 128000, costPer1kTokens: { input: 0.01, output: 0.03 }, description: 'Version preview de GPT-4, plus rapide' },
                        'gpt-3.5-turbo': { maxTokens: 4096, costPer1kTokens: { input: 0.0015, output: 0.002 }, description: 'Bon rapport qualité/prix, rapide' },
                        'gpt-3.5-turbo-16k': { maxTokens: 16384, costPer1kTokens: { input: 0.003, output: 0.004 }, description: 'GPT-3.5 avec contexte étendu' }
                    }
                }
            };
        }

        getDefaultConfig() {
            if (!this.AI_MODELS || !this.AI_MODELS.claude || !this.AI_MODELS.openai) {
                return {
                    provider: 'none',
                    apiKey: '',
                    endpoint: '',
                    maxCost: 0,
                    retryDelay: 1000,
                    maxRetries: 3,
                    enabledModels: { claude: [], openai: [] },
                    modelOrder: { claude: [], openai: [] },
                    preferredModel: ''
                };
            }
            return {
                provider: 'none',
                apiKey: '',
                endpoint: '',
                maxCost: 0,
                retryDelay: 1000,
                maxRetries: 3,
                enabledModels: {
                    claude: Object.keys(this.AI_MODELS.claude.models).slice(0, 2),
                    openai: Object.keys(this.AI_MODELS.openai.models).slice(0, 2)
                },
                modelOrder: {
                    claude: Object.keys(this.AI_MODELS.claude.models),
                    openai: Object.keys(this.AI_MODELS.openai.models)
                },
                preferredModel: ''
            };
        }

        initializeState() {
            var defaultConfig = this.getDefaultConfig();
            var savedConfig = JSON.parse(this.storage.getItem('aiConfig')) || {};
            this.state = {
                currentTab: this.storage.getItem('currentTab') || 'création',
                formData: JSON.parse(this.storage.getItem('formData')) || { name: '', cve: '', description: '' },
                aiConfig: Object.assign({}, defaultConfig, savedConfig, {
                    enabledModels: Object.assign({}, defaultConfig.enabledModels, savedConfig.enabledModels || {}),
                    modelOrder: Object.assign({}, defaultConfig.modelOrder, savedConfig.modelOrder || {}),
                    preferredModel: savedConfig.preferredModel || defaultConfig.preferredModel
                })
            };
            this.storage.setItem('aiConfig', JSON.stringify(this.state.aiConfig));
        }

        getUsageStatsHTML() {
            var stats = JSON.parse(this.storage.getItem('usageStats') || '{}');
            var provider = this.state.aiConfig.provider;
            if (provider === 'none' || !stats[provider]) {
                return '<p>Aucune statistique disponible</p>';
            }
            var usageRows = Object.entries(stats[provider]).map((entry) => {
                var model = entry[0];
                var data = entry[1];
                return '<div class="usage-row">' +
                    '<div class="model-name">' + model + '</div>' +
                    '<div class="usage-details">' +
                        '<span>Appels: ' + data.calls + '</span>' +
                        '<span>Tokens: ' + data.tokens.toLocaleString() + '</span>' +
                        '<span>Coût: $' + data.cost.toFixed(4) + '</span>' +
                    '</div>' +
                '</div>';
            }).join('');
            return '<div class="usage-table">' + usageRows + '<div class="usage-total"><strong>Total: $' + this.calculateTotalCost(stats[provider]).toFixed(4) + '</strong></div></div>';
        }

        calculateTotalCost(providerStats) {
            return Object.values(providerStats).reduce((total, data) => total + (data.cost || 0), 0);
        }

        updateUsageStats(provider, model, inputTokens, outputTokens) {
            var stats = JSON.parse(this.storage.getItem('usageStats') || '{}');
            if (!stats[provider]) stats[provider] = {};
            if (!stats[provider][model]) {
                stats[provider][model] = { calls: 0, tokens: 0, cost: 0 };
            }
            var modelInfo = this.AI_MODELS[provider].models[model];
            var inputCost = (inputTokens / 1000) * modelInfo.costPer1kTokens.input;
            var outputCost = (outputTokens / 1000) * modelInfo.costPer1kTokens.output;
            stats[provider][model].calls += 1;
            stats[provider][model].tokens += (inputTokens + outputTokens);
            stats[provider][model].cost += (inputCost + outputCost);
            this.storage.setItem('usageStats', JSON.stringify(stats));
            this.updateUsageDisplay();
        }

        updateUsageDisplay() {
            var usageStats = document.getElementById('usage-stats');
            if (usageStats) {
                usageStats.innerHTML = this.getUsageStatsHTML();
            }
        }

        resetUsageStats() {
            if (confirm('Voulez-vous vraiment réinitialiser toutes les statistiques d\'utilisation ?')) {
                this.storage.setItem('usageStats', JSON.stringify({}));
                this.updateUsageDisplay();
                this.showNotification('Statistiques réinitialisées', 'success');
            }
        }

        addUsageStyles() {
            var styles = document.createElement('style');
            styles.textContent = `
                .usage-table { margin-top: 1rem; }
                .usage-row { display: flex; justify-content: space-between; padding: 0.5rem; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
                .usage-details { display: flex; gap: 1rem; }
                .usage-total { margin-top: 1rem; text-align: right; color: var(--accent); }
                .model-name { font-weight: 500; }
            `;
            document.head.appendChild(styles);
        }

        getLibraryContent() {
            const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
            console.log("Displaying vulnerabilities:", vulnerabilities);
        
            if (!vulnerabilities.length) {
                return '<div class="card animate-in"><h2>Bibliothèque vide</h2><p style="color: var(--text-secondary);">Créez votre première vulnérabilité dans l\'onglet Création.</p></div>';
            }
        
            return vulnerabilities.map((vuln) => {
                const cveBadge = vuln.cve ? `<span class="badge badge-blue">${vuln.cve}</span>` : '';
                return `
                    <div class="card animate-in">
                        <div style="margin-bottom: 1rem;">
                            <h3 style="margin-bottom: 0.5rem;">${vuln.name}</h3>
                            ${cveBadge}
                        </div>
                        <p style="
                            color: var(--text-secondary); 
                            margin-bottom: 1rem; 
                            display: -webkit-box; 
                            -webkit-line-clamp: 3; /* Set this to 2 or 3 for the number of visible lines */ 
                            -webkit-box-orient: vertical; 
                            overflow: hidden; 
                            text-overflow: ellipsis;">
                            ${vuln.description}
                        </p>

                        <div class="flex">
                            <button class="btn btn-primary" onclick="app.showGame('${vuln.id}', 'analogy')">Mode Histoire</button>
                            <button class="btn btn-warning" onclick="app.showGame('${vuln.id}', 'technical')">Mode Technique</button>
                            <button class="btn btn-danger" onclick="app.deleteVulnerability('${vuln.id}')">Supprimer</button>
                        </div>
                    </div>`;
            }).join('');
        }

        createWall() {
            const existingWall = document.querySelector('#wall');
            if (!existingWall) {
                const wall = document.createElement('div');
                wall.id = 'wall';
                wall.className = 'grid';
                document.querySelector('.container').appendChild(wall);
            }
        }

        appendToTerminal(terminal, text, type) {
            const line = document.createElement('div');
            line.className = 'terminal-line';
            
            if (type === 'output') {
                line.innerHTML = `<span class="terminal-output">${text}</span>`;
            } else {
                line.innerHTML = `<span class="terminal-prompt">$</span><span class="terminal-output ${type}">${text}</span>`;
            }
            
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
        }

        showNotification(message, type) {
            var notification = document.createElement('div');
            notification.className = 'card animate-in';
            notification.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 1000; background: var(--' + type + '); padding: 1rem; color: ' + (type === 'danger' || type === 'warning' ? 'white' : 'black') + '; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);';
            notification.textContent = message;
            document.body.appendChild(notification);
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        getProgressionContent() {
            var progress = JSON.parse(this.storage.getItem('userProgress'));
            var vulnerabilities = JSON.parse(this.storage.getItem('vulnerabilities'));
            return '<div class="card animate-in"><h2>Votre Progression</h2><div style="margin-top: 1rem;"><div class="flex" style="margin-bottom: 1rem;"><div><h3 style="color: var(--success);">' + progress.totalScore + '</h3><p style="color: var(--text-secondary);">Score total</p></div><div><h3 style="color: var(--accent);">' + progress.completedGames.length + '</h3><p style="color: var(--text-secondary);">Scénarios terminés</p></div><div><h3 style="color: var(--warning);">' + vulnerabilities.length + '</h3><p style="color: var(--text-secondary);">Vulnérabilités créées</p></div></div><h3 style="margin: 1rem 0;">Dernières activités</h3>' + this.getRecentActivities() + '</div></div>';
        }

        getRecentActivities() {
            var progress = JSON.parse(this.storage.getItem('userProgress'));
            if (!progress.completedGames.length) {
                return '<p style="color: var(--text-secondary);">Aucune activité pour le moment</p>';
            }
            return '<div class="terminal" style="background: var(--bg-secondary);">' + progress.completedGames.sort((a, b) => b.timestamp - a.timestamp).slice(0, 5).map((game) => '<div class="terminal-line"><span class="terminal-prompt">></span><span class="terminal-output">' + game.name + ' - Mode ' + game.mode + ' <span style="color: var(--success);">+' + game.score + ' pts</span></span></div>').join('') + '</div>';
        }

        deleteVulnerability(id) {
            if (confirm('Êtes-vous sûr de vouloir supprimer cette vulnérabilité ?')) {
                let vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
                console.log("Vulnerabilities before deletion:", vulnerabilities);
                vulnerabilities = vulnerabilities.filter((vuln) => vuln.id.toString() !== id.toString());
                console.log("Vulnerabilities after filtering:", vulnerabilities);
                localStorage.setItem('vulnerabilities', JSON.stringify(vulnerabilities));
                const updatedVulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities'));
                console.log("Vulnerabilities in storage after deletion:", updatedVulnerabilities);
                this.showNotification('Vulnérabilité supprimée', 'success');
                this.loadCurrentTab();
            }
        }

buildAnalogyPrompt(name, cve, description) {
    const defaultPrompt = localStorage.getItem('defaultAnalogyPrompt') || 'Montre seulement index.html sans aucun commentaire.';
    return `${defaultPrompt}\nNom de la vulnérabilité: ${name}\nCVE: ${cve || 'n/a'}\nDescription: ${description}`;
}

buildTechnicalPrompt(name, cve, description) {
    const defaultPrompt = localStorage.getItem('defaultTechnicalPrompt') || `
        Crée un jeu interactif en JavaScript qui simule l'exploitation de la vulnérabilité ${name} (CVE: ${cve || 'n/a'}). Le jeu doit inclure :

        1. **Interface Utilisateur (UI) :** Une interface où l'utilisateur peut effectuer des actions spécifiques pour exploiter la vulnérabilité.
        2. **Conséquences :** Afficher les effets de chaque action de l'utilisateur sur le système cible.
        3. **Commentaires :** Inclure des commentaires détaillés dans le code expliquant chaque section et sa fonctionnalité.
        4. **Instructions :** Fournir des instructions claires pour guider l'utilisateur sur la manière de jouer et d'exploiter la vulnérabilité.
        5. **Sécurité :** S'assurer que le code est sécurisé et ne peut pas être utilisé de manière malveillante en dehors du contexte du jeu.

        Assure-toi que le code est bien structuré, utilise les meilleures pratiques de développement web, et inclut des éléments interactifs pour une expérience utilisateur engageante.
        Montre seulement index.html sans aucun commentaire.
    `;
    return `${defaultPrompt}\nNom de la vulnérabilité: ${name}\nCVE: ${cve || 'n/a'}\nDescription: ${description}`;
}



showLearningConfig() {
    const analogyPrompt = localStorage.getItem('defaultAnalogyPrompt') || 'Prompt par défaut pour le mode analogie...';
    const technicalPrompt = localStorage.getItem('defaultTechnicalPrompt') || 'Prompt par défaut pour le mode technique...';

    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
        <div class="modal-content card">
            <h2>Configuration des Prompts d'Apprentissage</h2>
            <div style="margin-top: 1rem;">
                <label>Prompt par défaut pour le mode analogie:</label>
                <textarea id="analogy-prompt-input" rows="4" class="input">${analogyPrompt}</textarea>
                <label>Prompt par défaut pour le mode technique:</label>
                <textarea id="technical-prompt-input" rows="4" class="input">${technicalPrompt}</textarea>
            </div>
            <div class="flex" style="margin-top: 1rem; gap: 1rem;">
                <button class="btn btn-primary" onclick="app.saveLearningConfig()">Sauvegarder</button>
                <button class="btn btn-danger" onclick="this.closest('.modal').remove()">Fermer</button>
            </div>
        </div>`;
    
    document.body.appendChild(modal);
}

saveLearningConfig() {
    const analogyPrompt = document.getElementById('analogy-prompt-input').value;
    const technicalPrompt = document.getElementById('technical-prompt-input').value;

    localStorage.setItem('defaultAnalogyPrompt', analogyPrompt);
    localStorage.setItem('defaultTechnicalPrompt', technicalPrompt);

    this.showNotification('Prompts sauvegardés avec succès', 'success');
    document.querySelector('.modal').remove();
}



showGame(vulnId, mode) {
    const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
    const vuln = vulnerabilities.find(v => v.id === vulnId.toString());
    if (!vuln) {
        this.showNotification('Vulnérabilité non trouvée.', 'danger');
        return;
    }

    const gameContent = mode === 'analogy' ? vuln.analogyCode : vuln.technicalCode;
    if (!gameContent) {
        this.showNotification('Le jeu sélectionné est manquant.', 'danger');
        return;
    }

    // Injecter directement le contenu sans re-créer l'HTML complet
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
        <div class="modal-content card">
            <h2>${vuln.name} - ${mode === 'analogy' ? 'Mode Histoire' : 'Mode Technique'}</h2>
            <div class="game-container">
                <iframe 
                    srcdoc="${DOMPurify.sanitize(gameContent)}"
                    sandbox="allow-modals allow-forms allow-scripts allow-same-origin allow-popups allow-pointer-lock allow-orientation-lock allow-top-navigation allow-popups-to-escape-sandbox allow-presentation"
                    style="background: #ffffff !important; width: 100%; height: 100%; border: none;"
                    frameborder="0">
                </iframe>
            </div>
            <div class="flex" style="margin-top: 1rem; gap: 1rem;">
                <button class="btn btn-primary" onclick="app.reloadGame('${vuln.id}', '${mode}')">
                    🔄 Recharger
                </button>
                <button class="btn btn-danger" onclick="this.closest('.modal').remove()">Fermer</button>
            </div>
        </div>`;

    document.body.appendChild(modal);

    // Style forcé après le chargement de l'iframe
    const iframe = modal.querySelector('iframe');
    iframe.onload = () => {
        const iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
        const style = iframeDocument.createElement('style');
        style.textContent = `
            body {
                background-color: #ffffff !important;
                color: #000000 !important;
            }
            p, h1, h2, h3, h4, h5, h6, span, div {
                color: #000000 !important;
            }
            button, .btn, .button {
                color: inherit;
            }
        `;
        iframeDocument.head.appendChild(style);
    };
}
showGame(vulnId, mode) {
    const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
    const vuln = vulnerabilities.find(v => v.id === vulnId.toString());
    if (!vuln) {
        this.showNotification('Vulnérabilité non trouvée.', 'danger');
        return;
    }

    const gameContent = mode === 'analogy' ? vuln.analogyCode : vuln.technicalCode;
    if (!gameContent) {
        this.showNotification('Le jeu sélectionné est manquant.', 'danger');
        return;
    }

    // Crée un blob pour permettre l'exécution du JavaScript
    const blob = new Blob([gameContent], { type: 'text/html' });
    const blobURL = URL.createObjectURL(blob);

    // Crée la modal sans recréer la structure HTML complète
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
        <div class="modal-content card">
            <h2>${vuln.name} - ${mode === 'analogy' ? 'Mode Histoire' : 'Mode Technique'}</h2>
            <div class="game-container">
                <iframe 
                    src="${blobURL}"
                    sandbox="allow-modals allow-forms allow-scripts allow-same-origin allow-popups allow-pointer-lock allow-orientation-lock allow-top-navigation allow-popups-to-escape-sandbox allow-presentation"
                    style="background: #ffffff !important; width: 100%; height: 100%; border: none;"
                    frameborder="0">
                </iframe>
            </div>
            <div class="flex" style="margin-top: 1rem; gap: 1rem;">
                <button class="btn btn-primary" onclick="app.reloadGame('${vuln.id}', '${mode}')">
                    🔄 Recharger
                </button>
                <button class="btn btn-danger" onclick="this.closest('.modal').remove()">Fermer</button>
            </div>
        </div>`;

    document.body.appendChild(modal);

    // Ajout du style après le chargement de l'iframe pour forcer le fond blanc et le texte noir
    const iframe = modal.querySelector('iframe');
    iframe.onload = () => {
        URL.revokeObjectURL(blobURL); // Libère l'URL après chargement
    };
}
showGame(vulnId, mode) {
    const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
    const vuln = vulnerabilities.find(v => v.id === vulnId.toString());
    if (!vuln) {
        this.showNotification('Vulnérabilité non trouvée.', 'danger');
        return;
    }

    const gameContent = mode === 'analogy' ? vuln.analogyCode : vuln.technicalCode;
    if (!gameContent) {
        this.showNotification('Le jeu sélectionné est manquant.', 'danger');
        return;
    }

    // Utiliser DOMPurify pour assainir le contenu avant de l'injecter dans l'iframe
    const sanitizedContent = DOMPurify.sanitize(gameContent, { USE_PROFILES: { html: true } });

    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
        <div class="modal-content card">
            <h2>${vuln.name} - ${mode === 'analogy' ? 'Mode Histoire' : 'Mode Technique'}</h2>
            <div class="game-container">
                <iframe 
                    srcdoc="${sanitizedContent}"
                    sandbox="allow-modals allow-forms allow-scripts allow-same-origin"
                    style="background: #ffffff; width: 100%; height: 100%; border: none;"
                    frameborder="0">
                </iframe>
            </div>
            <div class="flex" style="margin-top: 1rem; gap: 1rem;">
                <button class="btn btn-primary" onclick="app.reloadGame('${vuln.id}', '${mode}')">
                    🔄 Recharger
                </button>
                <button class="btn btn-danger" onclick="this.closest('.modal').remove()">Fermer</button>
            </div>
        </div>`;

    document.body.appendChild(modal);
}
showGame(vulnId, mode) {
    const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
    const vuln = vulnerabilities.find(v => v.id === vulnId.toString());
    if (!vuln) {
        this.showNotification('Vulnérabilité non trouvée.', 'danger');
        return;
    }

    const gameContent = mode === 'analogy' ? vuln.analogyCode : vuln.technicalCode;
    if (!gameContent) {
        this.showNotification('Le jeu sélectionné est manquant.', 'danger');
        return;
    }
    
    function escapeHTML(content) {
        return content
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;")
            .replace(/`/g, "&#96;"); // Échappe les backticks
    }

    // Appliquer l'échappement manuel des caractères spéciaux
    const escapedContent = escapeHTML(gameContent);

    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
        <div class="modal-content card">
            <h2>${vuln.name} - ${mode === 'analogy' ? 'Mode Histoire' : 'Mode Technique'}</h2>
            <div class="game-container">
                <iframe 
                    srcdoc="${escapedContent}"
                    sandbox="allow-modals allow-forms allow-scripts allow-same-origin"
                    style="background: #ffffff; width: 100%; height: 100%; border: none;"
                    frameborder="0">
                </iframe>
            </div>
            <div class="flex" style="margin-top: 1rem; gap: 1rem;">
                <button class="btn btn-primary" onclick="app.reloadGame('${vuln.id}', '${mode}')">
                    🔄 Recharger
                </button>
                <button class="btn btn-danger" onclick="this.closest('.modal').remove()">Fermer</button>
            </div>
        </div>`;

    document.body.appendChild(modal);
}




        injectGamesIntoWall(vulnerability) {
            const wallElement = document.querySelector('#wall');
            if (!wallElement) {
                this.showNotification("L'élément du wall n'a pas été trouvé.", 'danger');
                return;
            }

            wallElement.innerHTML += `
                <div class="vulnerability-card" id="${vulnerability.id}">
                    <h3>${vulnerability.name} (CVE: ${vulnerability.cve})</h3>
                    <div class="game-container">
                        <h4>Mode Histoire</h4>
                        <iframe srcdoc="${vulnerability.analogyCode}" sandbox="allow-modals allow-forms allow-scripts allow-same-origin allow-popups allow-pointer-lock allow-orientation-lock allow-top-navigation allow-popups-to-escape-sandbox allow-presentation" width="100%" height="300px"></iframe>
                    </div>
                    <div class="game-container">
                        <h4>Mode Technique</h4>
                        <iframe srcdoc="${vulnerability.technicalCode}" sandbox="allow-modals rallow-forms allow-scripts allow-same-origin allow-popups allow-pointer-lock allow-orientation-lock allow-top-navigation allow-popups-to-escape-sandbox allow-presentation" width="100%" height="300px"></iframe>
                    </div>
                </div>`;
        }


        async retrySpecificMode(mode, name, cve, description, maxRetries = 3) {
            let retryCount = 0;
            while (retryCount < maxRetries) {
                this.log(`Tentative ${retryCount + 1}/${maxRetries} pour le mode ${mode}...`, 'info');
                
                try {
                    const prompt = mode === 'analogy' 
                        ? this.buildAnalogyPrompt(name, cve, description)
                        : this.buildTechnicalPrompt(name, cve, description);
                    
                    let response = await this.callAI(prompt);
                    response = await this.validateAndRetryGeneration(response);
                    
                    const validation = this.validateGameContent(response);
                    if (validation.isValid) {
                        this.log(`Mode ${mode} généré avec succès.`, 'success');
                        return { isValid: true, code: response };
                    }
                } catch (error) {
                    this.log(`Erreur lors de la tentative ${retryCount + 1}: ${error.message}`, 'error');
                }
                
                retryCount++;
                await new Promise(resolve => setTimeout(resolve, this.retryDelay));
            }
            
            return { isValid: false, code: null };
        }
        
async saveAIConfig() {
    const provider = document.getElementById('ai-provider').value;
    const apiKey = document.getElementById('ai-key').value;
    const endpoint = document.getElementById('ai-endpoint').value;
    const preferredModel = document.getElementById('model-select').value;
    
    const newConfig = {
        provider,
        apiKey,
        endpoint,
        preferredModel
    };
    
    // Mettre à jour le gestionnaire d'API
    this.apiManager.updateConfig(newConfig);
    
    // Valider la configuration
    const validation = this.apiManager.validateConfig();
    if (!validation.isValid) {
        this.showNotification(`Configuration invalide: ${validation.errors.join(', ')}`, 'danger');
        return;
    }
    
    // Sauvegarder dans le localStorage
    localStorage.setItem('aiConfig', JSON.stringify(newConfig));
    this.updateAIBadge();
    this.showNotification('Configuration IA sauvegardée', 'success');
}



validateGameContent(code) {
    // Validation de base
    const validation = CodeValidator.validateGameCode(code);

    // Vérifications supplémentaires
    const hasInteractiveElements = code.includes('onclick') || 
                                code.includes('addEventListener') || 
                                code.includes('input') ||
                                code.includes('button') ||
                                code.includes('function '); // S'assurer qu'au moins une fonction est définie
    
    const hasProperStructure = code.includes('<!DOCTYPE html>') &&
                             code.includes('<html') &&
                             code.includes('<head') &&
                             code.includes('<body');

    // Log des validations
    this.log(`Validation - Éléments interactifs: ${hasInteractiveElements}`, 'info');
    this.log(`Validation - Structure HTML: ${hasProperStructure}`, 'info');

    return {
        isValid: validation.isValid && hasInteractiveElements && hasProperStructure,
        messages: [
            ...validation.messages,
            !hasInteractiveElements ? 'Pas d\'éléments interactifs trouvés' : null,
            !hasProperStructure ? 'Structure HTML incorrecte' : null
        ].filter(Boolean)
    };
}



        async updateExistingVulnerability(vulnId, mode, code) {
            const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
            const index = vulnerabilities.findIndex(v => v.id === vulnId);
            
            if (index !== -1) {
                if (mode === 'analogy') {
                    vulnerabilities[index].analogyCode = code;
                } else {
                    vulnerabilities[index].technicalCode = code;
                }
                
                localStorage.setItem('vulnerabilities', JSON.stringify(vulnerabilities));
                this.log(`Mode ${mode} mis à jour pour la vulnérabilité ${vulnId}`, 'success');
                return true;
            }
            
            return false;
        }

async callClaude(prompt) {
    const selectedModel = this.state.aiConfig.preferredModel;
    const apiKey = this.state.aiConfig.apiKey;

    // Vérification de la clé API et du modèle
    if (!apiKey) {
        throw new Error('API Key for Claude is missing. Please configure it in the settings.');
    }
    if (!selectedModel) {
        throw new Error('No model selected for Claude API. Please choose a model.');
    }

    const url = this.state.aiConfig.endpoint || 'https://api.anthropic.com/v1/messages';

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': apiKey,
                'anthropic-version': '2023-06-01',
                'anthropic-dangerous-direct-browser-access': 'true'
            },
            body: JSON.stringify({
                model: selectedModel,
                messages: [{ role: 'user', content: prompt }],
                max_tokens: 4096
            })
        });

        // Vérification du code d'état HTTP
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Claude API Error (${response.status}): ${errorText}`);
        }

        const result = await response.json();
        return result.content[0].text.trim();
    } catch (error) {
        console.error('Error in callClaude:', error);
        throw new Error(`Failed to fetch from Claude API: ${error.message}`);
    }
}

async callChatGPT(prompt) {
    const selectedModel = this.state.aiConfig.preferredModel;
    const apiKey = this.state.aiConfig.apiKey;

    // Vérification de la clé API et du modèle
    if (!apiKey) {
        throw new Error('API Key for OpenAI is missing. Please configure it in the settings.');
    }
    if (!selectedModel) {
        throw new Error('No model selected for OpenAI API. Please choose a model.');
    }

    const url = 'https://api.openai.com/v1/chat/completions';

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify({
                model: selectedModel,
                messages: [{ role: 'user', content: prompt }],
                temperature: 0.7
            })
        });

        // Vérification du code d'état HTTP
        if (!response.ok) {
            const error = await response.json();
            throw new Error(`OpenAI API Error (${response.status}): ${error.message || 'Unknown error'}`);
        }

        const data = await response.json();
        return data.choices[0].message.content;
    } catch (error) {
        console.error('Error in callChatGPT:', error);
        throw new Error(`Failed to fetch from OpenAI API: ${error.message}`);
    }
}


        initializeFormListeners() {
            const nameInput = document.querySelector('input[placeholder="Nom de la vulnérabilité"]');
            const cveInput = document.querySelector('input[placeholder="Identifiant CVE (optionnel)"]');
            const descTextarea = document.querySelector('textarea[placeholder="Description détaillée"]');
            
            if (!nameInput || !cveInput || !descTextarea) {
                console.warn("Form elements not found. Skipping initialization.");
                return;
            }
        
            nameInput.value = this.state.formData.name;
            cveInput.value = this.state.formData.cve;
            descTextarea.value = this.state.formData.description;
        
            const updateStorage = () => {
                this.state.formData = {
                    name: nameInput.value,
                    cve: cveInput.value,
                    description: descTextarea.value
                };
                this.storage.setItem('formData', JSON.stringify(this.state.formData));
            };
        
            nameInput.addEventListener('input', updateStorage);
            cveInput.addEventListener('input', updateStorage);
            descTextarea.addEventListener('input', updateStorage);
        }

        initializeStorage() {
            if (!this.storage.getItem('vulnerabilities')) {
                this.storage.setItem('vulnerabilities', JSON.stringify([]));
            }
            if (!this.storage.getItem('userProgress')) {
                this.storage.setItem('userProgress', JSON.stringify({ completedGames: [], totalScore: 0 }));
            }
            if (!this.storage.getItem('formData')) {
                this.storage.setItem('formData', JSON.stringify({ name: '', cve: '', description: '' }));
            }
        }

        updateAIBadge() {
            var badge = document.querySelector('#ai-config-btn .badge');
            if (this.state.aiConfig.provider !== 'none') {
                badge.className = 'badge badge-blue';
                badge.textContent = 'IA: ' + this.state.aiConfig.provider;
            } else {
                badge.className = 'badge badge-warning';
                badge.textContent = 'IA: Non configurée';
            }
        }

        completeGame(vulnId, mode) {
            var vulnerabilities = JSON.parse(this.storage.getItem('vulnerabilities'));
            var vuln = vulnerabilities.find((v) => v.id === vulnId);
            if (!vuln) return;
            var progress = JSON.parse(this.storage.getItem('userProgress'));
            var score = mode === 'analogy' ? 10 : 20;
            progress.completedGames.push({ id: vulnId, name: vuln.name, mode: mode, score: score, timestamp: Date.now() });
            progress.totalScore += score;
            this.storage.setItem('userProgress', JSON.stringify(progress));
            this.showNotification('+' + score + ' points gagnés !', 'success');
            document.querySelector('.modal').remove();
            this.loadCurrentTab();
        }
      
      
// Ajout des configurations Firebase dans l'interface IA
        showAIConfig() {
            console.log('Ouverture de la configuration IA'); // Debug
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'flex'; // Forcer l'affichage
            modal.innerHTML = `
                <div class="modal-content card" style="width: 90%; max-width: 800px;">
                    <h2>Configuration</h2>
                    <div class="tab-group" style="margin: 1rem 0;">
                        <div class="config-tab active" onclick="app.switchConfigTab(this, 'ai')">IA</div>
                        <div class="config-tab" onclick="app.switchConfigTab(this, 'firebase')">Firebase</div>
                    </div>
                    
                    <div id="ai-config" class="config-section">
                        <div class="provider-select">
                            <select class="input" id="ai-provider" onchange="app.updateProviderConfig(this.value)">
                                <option value="none" ${this.state.aiConfig.provider === 'none' ? 'selected' : ''}>
                                    Choisir un provider
                                </option>
                                <option value="claude" ${this.state.aiConfig.provider === 'claude' ? 'selected' : ''}>
                                    Claude (Anthropic)
                                </option>
                                <option value="openai" ${this.state.aiConfig.provider === 'openai' ? 'selected' : ''}>
                                    ChatGPT (OpenAI)
                                </option>
                            </select>
                        </div>

                        <div id="model-config" class="provider-config" style="margin-top: 1rem;">
                            ${this.generateModelConfigHTML()}
                        </div>

                        <input type="password" class="input" id="ai-key" 
                            placeholder="Clé API" value="${this.state.aiConfig.apiKey || ''}">
                        <input type="text" class="input" id="ai-endpoint" 
                            placeholder="Endpoint (optionnel)" value="${this.state.aiConfig.endpoint || ''}">

                        <div class="global-settings">
                            <h3>Paramètres globaux</h3>
                            <div class="input-group">
                                <label>Budget maximum par requête (USD)</label>
                                <input type="number" class="input" id="max-cost"
                                    value="${this.state.aiConfig.maxCost || 0.60}"
                                    step="0.01" min="0">
                            </div>
                            <div class="input-group">
                                <label>Délai entre tentatives (ms)</label>
                                <input type="number" class="input" id="retry-delay"
                                    value="${this.state.aiConfig.retryDelay || 1000}"
                                    min="500">
                            </div>
                            <div class="input-group">
                                <label>Nombre maximum de tentatives</label>
                                <input type="number" class="input" id="max-retries"
                                    value="${this.state.aiConfig.maxRetries || 3}"
                                    min="1" max="5">
                            </div>
                        </div>

                        <div class="usage-stats">
                            <h3>Statistiques d'utilisation</h3>
                            <div id="usage-stats">
                                ${this.getUsageStatsHTML()}
                            </div>
                        </div>
                    </div>

                    <div id="firebase-config" class="config-section" style="display: none;">
                        <!-- Contenu Firebase -->
                    </div>

                    <div class="flex" style="margin-top: 1rem; gap: 1rem;">
                        <button class="btn btn-primary" onclick="app.saveAIConfig()">Sauvegarder</button>
                        <button class="btn btn-secondary" onclick="app.testConnection()">Tester la connexion</button>
                        <button class="btn btn-warning" onclick="app.resetUsageStats()">
                            Réinitialiser les statistiques
                        </button>
                        <button class="btn btn-danger" onclick="this.closest('.modal').remove()">Fermer</button>
                    </div>
                </div>
            `;

            // Ajouter les styles
            this.addAIConfigStyles();
            
            // Ajouter la modal au body
            document.body.appendChild(modal);
            
            // Initialiser les gestionnaires d'événements
            this.initializeConfigHandlers();
        }
        
initializeConfigHandlers() {
    // Get the AI config elements from the DOM
    const providerSelect = document.getElementById('ai-provider-select');
    const apiKeyInput = document.getElementById('ai-api-key');
    const endpointInput = document.getElementById('ai-endpoint');
    const saveButton = document.getElementById('save-ai-config');
    const testConnectionButton = document.getElementById('test-ai-connection');

    // Check if each element exists before trying to set its properties
    if (providerSelect) {
        providerSelect.value = this.state.aiConfig.provider;
        providerSelect.onchange = () => {
            this.state.aiConfig.provider = providerSelect.value;
        };
    }

    if (apiKeyInput) {
        apiKeyInput.value = this.state.aiConfig.apiKey;
        apiKeyInput.oninput = () => {
            this.state.aiConfig.apiKey = apiKeyInput.value;
        };
    }

    if (endpointInput) {
        endpointInput.value = this.state.aiConfig.endpoint;
        endpointInput.oninput = () => {
            this.state.aiConfig.endpoint = endpointInput.value;
        };
    }

    if (saveButton) {
        saveButton.onclick = () => {
            const newConfig = {
                provider: providerSelect ? providerSelect.value : '',
                apiKey: apiKeyInput ? apiKeyInput.value : '',
                endpoint: endpointInput ? endpointInput.value : ''
            };

            this.saveAIConfig(newConfig);
            this.showNotification('Configuration sauvegardée avec succès.', 'success');
        };
    }

    if (testConnectionButton) {
        testConnectionButton.onclick = () => {
            this.testConnection();
        };
    }
}


    // Méthode centrale pour sauvegarder l'état
    saveState() {
        this.storage.setItem('aiConfig', JSON.stringify(this.state.aiConfig));
        this.storage.setItem('currentTab', this.state.currentTab);
        this.storage.setItem('formData', JSON.stringify(this.state.formData));
    }

    // Mise à jour de updateProviderConfig
    updateProviderConfig(provider) {
        this.state.aiConfig.provider = provider;
        this.saveState(); // Sauvegarde immédiate
        
        const modelConfigContainer = document.getElementById('model-config');
        if (modelConfigContainer) {
            modelConfigContainer.innerHTML = this.generateModelConfigHTML();
        }

        this.updateAIBadge();
    }

    // Mise à jour de setPreferredModel
    setPreferredModel(selectedModel) {
        this.state.aiConfig.preferredModel = selectedModel;
        this.saveState(); // Sauvegarde immédiate
        this.showNotification(`Modèle préféré mis à jour: ${selectedModel}`, 'success');
    }

    // Mise à jour de saveAIConfig
    async saveAIConfig() {
        const provider = document.getElementById('ai-provider').value;
        const apiKey = document.getElementById('ai-key').value;
        const endpoint = document.getElementById('ai-endpoint').value;
        const preferredModel = document.getElementById('model-select').value;
        const maxCost = document.getElementById('max-cost').value;
        const retryDelay = document.getElementById('retry-delay').value;
        const maxRetries = document.getElementById('max-retries').value;
        
        const newConfig = {
            provider,
            apiKey,
            endpoint,
            preferredModel,
            maxCost: parseFloat(maxCost),
            retryDelay: parseInt(retryDelay),
            maxRetries: parseInt(maxRetries)
        };
        
        // Mettre à jour l'état local
        this.state.aiConfig = {
            ...this.state.aiConfig,
            ...newConfig
        };
        
        // Sauvegarder immédiatement
        this.saveState();
        
        // Mettre à jour l'APIManager
        this.apiManager.updateConfig(newConfig);
        
        // Valider la configuration
        const validation = this.apiManager.validateConfig();
        if (!validation.isValid) {
            this.showNotification(`Configuration invalide: ${validation.errors.join(', ')}`, 'danger');
            return;
        }
        
        this.updateAIBadge();
        this.showNotification('Configuration IA sauvegardée', 'success');
    }

    // Mise à jour des gestionnaires de formulaire
    initializeFormListeners() {
        const nameInput = document.querySelector('input[placeholder="Nom de la vulnérabilité"]');
        const cveInput = document.querySelector('input[placeholder="Identifiant CVE (optionnel)"]');
        const descTextarea = document.querySelector('textarea[placeholder="Description détaillée"]');
        
        if (!nameInput || !cveInput || !descTextarea) {
            console.warn("Form elements not found. Skipping initialization.");
            return;
        }
        
        nameInput.value = this.state.formData.name;
        cveInput.value = this.state.formData.cve;
        descTextarea.value = this.state.formData.description;
        
        const updateStorage = () => {
            this.state.formData = {
                name: nameInput.value,
                cve: cveInput.value,
                description: descTextarea.value
            };
            this.saveState(); // Sauvegarde immédiate
        };
        
        nameInput.addEventListener('input', updateStorage);
        cveInput.addEventListener('input', updateStorage);
        descTextarea.addEventListener('input', updateStorage);
    }

    // Mise à jour de testConnection pour sauvegarder l'état après test
 async testConnection() {
    try {
        // Définir un prompt de test approprié en fonction du fournisseur d'IA
        let testPrompt = 'Test de connexion à l\'API IA. Veuillez répondre par "OK".';
        
        // Optionnel : Adapter le prompt en fonction du fournisseur
        if (this.state.aiConfig.provider === 'claude') {
            testPrompt = 'Bonjour Claude, réponds simplement par "OK" pour confirmer la connexion.';
        } else if (this.state.aiConfig.provider === 'openai') {
            testPrompt = 'Hello ChatGPT, please respond with "OK" to confirm the connection.';
        } else {
            throw new Error('Aucun fournisseur d\'IA sélectionné pour le test de connexion.');
        }

        // Appeler l'API avec le prompt de test
        const response = await this.apiManager.callAPI(testPrompt);
        
        // Vérifier si la réponse contient "OK"
        if (response && response.includes('OK')) {
            // Sauvegarder l'état après un test réussi
            this.saveState();
            this.showNotification('Connexion établie avec succès!', 'success');
            return { success: true, message: 'Connexion établie avec succès!' };
        } else {
            throw new Error('La réponse de l\'API n\'est pas conforme.');
        }
        
    } catch (error) {
        console.error('Test connection failed:', error);
        this.showNotification(`Échec de la connexion: ${error.message}`, 'danger');
        return { success: false, message: error.message };
    }
}



        // Gestion de Firebase
        initializeFirebase() {
            const config = JSON.parse(localStorage.getItem('firebaseConfig'));
            if (!config) return;

            if (!window.firebase) {
                const script = document.createElement('script');
                script.src = 'https://www.gstatic.com/firebasejs/9.x.x/firebase-app.js';
                script.onload = () => {
                    const analyticsScript = document.createElement('script');
                    analyticsScript.src = 'https://www.gstatic.com/firebasejs/9.x.x/firebase-firestore.js';
                    analyticsScript.onload = () => {
                        this.initializeFirebaseApp(config);
                    };
                    document.head.appendChild(analyticsScript);
                };
                document.head.appendChild(script);
            } else {
                this.initializeFirebaseApp(config);
            }
        }

        async initializeFirebaseApp(config) {
            try {
                this.firebaseApp = firebase.initializeApp(config);
                this.db = firebase.firestore();
                console.log('Firebase initialized successfully');
            } catch (error) {
                console.error('Firebase initialization error:', error);
            }
        }
        
    /**
     * Méthode pour tester la connexion avec le fournisseur d'IA configuré.
     */



        async saveFirebaseConfig() {
            const config = {
                apiKey: document.getElementById('firebase-apiKey').value,
                authDomain: document.getElementById('firebase-authDomain').value,
                projectId: document.getElementById('firebase-projectId').value,
                storageBucket: document.getElementById('firebase-storageBucket').value,
                messagingSenderId: document.getElementById('firebase-messagingSenderId').value,
                appId: document.getElementById('firebase-appId').value
            };

            localStorage.setItem('firebaseConfig', JSON.stringify(config));
            this.state.firebaseConfig = config;
            this.initializeFirebase();
            this.showNotification('Configuration Firebase sauvegardée', 'success');
        }

        async testFirebaseConnection() {
            try {
                if (!this.db) {
                    throw new Error('Firebase n\'est pas initialisé');
                }
                await this.db.collection('test').add({
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                });
                this.showNotification('Connexion Firebase réussie', 'success');
            } catch (error) {
                this.showNotification('Erreur de connexion Firebase: ' + error.message, 'danger');
            }
        }

        async syncVulnerabilities() {
            if (!this.db) {
                this.showNotification('Firebase n\'est pas configuré', 'danger');
                return;
            }

            try {
                const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
                
                // Organiser les vulnérabilités par mode
                const organizedVulns = {
                    histoire: vulnerabilities.filter(v => v.analogyCode),
                    technique: vulnerabilities.filter(v => v.technicalCode)
                };

                // Mise à jour de Firebase
                const batch = this.db.batch();
                
                // Collection pour le mode histoire
                for (const vuln of organizedVulns.histoire) {
                    const ref = this.db.collection('vulnerabilites').doc('histoire').collection('jeux').doc(vuln.id);
                    batch.set(ref, {
                        ...vuln,
                        lastSync: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }

                // Collection pour le mode technique
                for (const vuln of organizedVulns.technique) {
                    const ref = this.db.collection('vulnerabilites').doc('technique').collection('jeux').doc(vuln.id);
                    batch.set(ref, {
                        ...vuln,
                        lastSync: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }

                await batch.commit();
                this.showNotification('Synchronisation réussie', 'success');
            } catch (error) {
                this.showNotification('Erreur de synchronisation: ' + error.message, 'danger');
            }
        }

        // Style pour les onglets de configuration
        addConfigStyles() {
            const styles = document.createElement('style');
            styles.textContent = `
                .config-tab {
                    padding: 0.5rem 1rem;
                    cursor: pointer;
                    border-radius: 0.5rem;
                    color: var(--text-secondary);
                    background: var(--bg-secondary);
                    
                }

                .config-tab.active {
                    background: var(--accent);
                }

                .config-section {
                    margin-top: 1rem;
                }
            `;
            document.head.appendChild(styles);
        }

        switchConfigTab(tab, section) {
            // Gérer l'activation des onglets
            document.querySelectorAll('.config-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');

            // Afficher la section correspondante
            document.querySelectorAll('.config-section').forEach(s => s.style.display = 'none');
            document.getElementById(`${section}-config`).style.display = 'block';
        }
        
setPreferredModel(selectedModel) {
    this.state.aiConfig.preferredModel = selectedModel;
    this.storage.setItem('aiConfig', JSON.stringify(this.state.aiConfig));
    this.showNotification(`Modèle préféré mis à jour: ${selectedModel}`, 'success');
}

    
    /**
     * Génère le HTML pour la configuration des modèles AI en fonction du fournisseur sélectionné.
     * @returns {string} - Le HTML généré pour la sélection des modèles.
     */
generateModelConfigHTML() {
    const provider = this.state.aiConfig.provider;

    if (provider === 'none') {
        return '<p>Veuillez sélectionner un fournisseur d\'IA pour configurer les modèles.</p>';
    }

    const models = this.AI_MODELS[provider].models;
    let html = `
        <label for="model-select">Sélectionnez un modèle :</label>
        <select class="input" id="model-select" onchange="app.setPreferredModel(this.value)">
    `;
    for (const model in models) {
        const selected = this.state.aiConfig.preferredModel === model ? 'selected' : '';
        html += `<option value="${model}" ${selected}>${model} - ${models[model].description}</option>`;
    }
    html += '</select>';

    return html;
}


    // Méthode pour ajouter les styles de configuration AI
    addAIConfigStyles() {
        const style = document.createElement('style');
        style.innerHTML = `
            /* Styles pour le modal de configuration IA */
            .modal {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                background: rgba(0, 0, 0, 0.6);
                z-index: 1000;
            }
            .modal-content {
                background: black;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
                max-width: 600px;
                width: 100%;
            }
            .tab-group {
                display: flex;
                gap: 1rem;
            }
            .config-tab {
                padding: 0.5rem 1rem;
                cursor: pointer;
                border-radius: 0.5rem;
                background: #f0f0f0;
                color : #333;
            }
            .config-tab.active {
                background: #007bff;
                color: white;
            }
            .provider-select select {
                width: 100%;
                padding: 0.5rem;
                margin-top: 1rem;
            }
            .input-group label {
                font-weight: bold;
            }
            .input-group input {
                width: 100%;
                padding: 0.5rem;
                margin-top: 0.5rem;
                margin-bottom: 1rem;
            }
        `;
        document.head.appendChild(style);
    }


    async generateVulnerability() {
        const terminal = document.querySelector('.logs-content');
        if (terminal) terminal.innerHTML = '';

        const progressBar = document.querySelector('.progress-bar');
        if (progressBar) progressBar.style.width = '0%';

        const { name, cve, description } = this.state.formData;
        if (!name || !description) {
            this.showNotification('Veuillez remplir les champs requis', 'danger');
            return;
        }

        const generateButton = document.querySelector('.btn-primary');
        generateButton.disabled = true;

        try {
            this.log('Début de la génération...', 'info');
            await new Promise(resolve => setTimeout(resolve, 1000));

            let vulnerability = {
                id: Date.now().toString(),
                name,
                cve,
                description,
                created: new Date().toISOString(),
                analogyPrompt: this.buildAnalogyPrompt(name, cve, description),
                technicalPrompt: this.buildTechnicalPrompt(name, cve, description)
            };

            // Génération du scénario analogique
            this.log('Génération du scénario analogique...', 'info');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            let analogyResponse = await this.callAI(vulnerability.analogyPrompt);
            this.log('Réponse reçue du scénario analogique, validation en cours...', 'info');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            analogyResponse = await this.validateAndRetryGeneration(analogyResponse);
            
            // Pause entre les générations
            this.log('Préparation de la génération technique...', 'info');
            await new Promise(resolve => setTimeout(resolve, 2000));

            // Génération du scénario technique
            this.log('Génération du scénario technique...', 'info');
            let technicalResponse = await this.callAI(vulnerability.technicalPrompt);
            
            this.log('Réponse reçue du scénario technique, validation en cours...', 'info');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            technicalResponse = await this.validateAndRetryGeneration(technicalResponse);

            // Sauvegarde avec délai
            this.log('Sauvegarde des scénarios...', 'info');
            await new Promise(resolve => setTimeout(resolve, 1000));

            vulnerability.analogyCode = analogyResponse;
            vulnerability.technicalCode = technicalResponse;

            const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
            vulnerabilities.push(vulnerability);
            localStorage.setItem('vulnerabilities', JSON.stringify(vulnerabilities));

            this.log('Génération terminée avec succès!', 'success');
            this.showNotification('Vulnérabilité créée avec succès!', 'success');
            
            await new Promise(resolve => setTimeout(resolve, 1000));
            this.loadCurrentTab();

        } catch (error) {
            console.error('Generation error:', error);
            this.log(`Erreur: ${error.message}`, 'error');
            this.showNotification(error.message, 'danger');
            if (progressBar) {
                progressBar.style.backgroundColor = 'var(--danger)';
            }
        } finally {
            await new Promise(resolve => setTimeout(resolve, 1000));
            generateButton.disabled = false;
            this.storage.removeItem('generationInProgress');
        }
    }



    async generateVulnerability() {
        const terminal = document.querySelector('.logs-content');
        if (terminal) terminal.innerHTML = '';

        const progressBar = document.querySelector('.progress-bar');
        if (progressBar) progressBar.style.width = '0%';

        const { name, cve, description } = this.state.formData;
        if (!name || !description) {
            this.showNotification('Veuillez remplir les champs requis', 'danger');
            return;
        }

        const generateButton = document.querySelector('.btn-primary');
        generateButton.disabled = true;

        try {
            this.log('Début de la génération...', 'info');
            await new Promise(resolve => setTimeout(resolve, 1000));

            let vulnerability = {
                id: Date.now().toString(),
                name,
                cve,
                description,
                created: new Date().toISOString(),
                analogyPrompt: this.buildAnalogyPrompt(name, cve, description),
                technicalPrompt: this.buildTechnicalPrompt(name, cve, description)
            };

            // Génération du scénario analogique
            this.log('Génération du scénario analogique...', 'info');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            let analogyResponse = await this.callAI(vulnerability.analogyPrompt);
            this.log('Réponse reçue du scénario analogique, validation en cours...', 'info');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            analogyResponse = await this.validateAndRetryGeneration(analogyResponse);
            
            // Pause entre les générations
            this.log('Préparation de la génération technique...', 'info');
            await new Promise(resolve => setTimeout(resolve, 2000));

            // Génération du scénario technique
            this.log('Génération du scénario technique...', 'info');
            let technicalResponse = await this.callAI(vulnerability.technicalPrompt);
            
            this.log('Réponse reçue du scénario technique, validation en cours...', 'info');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            technicalResponse = await this.validateAndRetryGeneration(technicalResponse);

            // Sauvegarde avec délai
            this.log('Sauvegarde des scénarios...', 'info');
            await new Promise(resolve => setTimeout(resolve, 1000));

            vulnerability.analogyCode = analogyResponse;
            vulnerability.technicalCode = technicalResponse;

            const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
            vulnerabilities.push(vulnerability);
            localStorage.setItem('vulnerabilities', JSON.stringify(vulnerabilities));

            this.log('Génération terminée avec succès!', 'success');
            this.showNotification('Vulnérabilité créée avec succès!', 'success');
            
            await new Promise(resolve => setTimeout(resolve, 1000));
            this.loadCurrentTab();

        } catch (error) {
            console.error('Generation error:', error);
            this.log(`Erreur: ${error.message}`, 'error');
            this.showNotification(error.message, 'danger');
            if (progressBar) {
                progressBar.style.backgroundColor = 'var(--danger)';
            }
        } finally {
            await new Promise(resolve => setTimeout(resolve, 1000));
            generateButton.disabled = false;
            this.storage.removeItem('generationInProgress');
        }
    }


    /**
     * Méthode pour valider le contenu généré par l'IA.
     * @param {string} code - Le code généré par l'IA.
     * @returns {object} - Résultat de la validation.
     */
    validateGameContent(code) {
        // Validation de base
        const validation = CodeValidator.validateGameCode(code);

        // Vérifications supplémentaires
        const hasInteractiveElements = code.includes('onclick') || 
                                        code.includes('addEventListener') || 
                                        code.includes('input') ||
                                        code.includes('button') ||
                                        code.includes('function '); // AJOUTÉ : Vérifier la présence d'une fonction

        const hasProperStructure = code.includes('<!DOCTYPE html>') &&
                                    code.includes('<html') &&
                                    code.includes('<head') &&
                                    code.includes('<body');

        // Log des validations
        this.log(`Validation - Éléments interactifs: ${hasInteractiveElements}`, 'info');
        this.log(`Validation - Structure HTML: ${hasProperStructure}`, 'info');

        return {
            isValid: validation.isValid && hasInteractiveElements && hasProperStructure,
            messages: [
                ...validation.messages,
                !hasInteractiveElements ? 'Pas d\'éléments interactifs trouvés' : null,
                !hasProperStructure ? 'Structure HTML incorrecte' : null
            ].filter(Boolean)
        };
    }

    /**
     * Méthode pour valider et réessayer la génération du code.
     * @param {string} code - Le code généré par l'IA.
     * @param {number} retryCount - Le nombre de tentatives effectuées.
     * @returns {string} - Le code validé ou corrigé.
     */
    async validateAndRetryGeneration(code, retryCount = 0) {
        const validation = CodeValidator.validateGameCode(code);

        if (!validation.isValid && retryCount < this.maxRetries) {
            this.log(`Validation échouée: ${validation.messages.join(', ')}`, 'warning');
            this.log(`Tentative ${retryCount + 1}/${this.maxRetries} de régénération...`, 'info');

            await new Promise(resolve => setTimeout(resolve, this.retryDelay));

            let correctionPrompt = `Le code généré nécessite les corrections suivantes:
${validation.messages.map(msg => `- ${msg}`).join('\n')}
${code}
RAPPEL DES CONTRAINTES OBLIGATOIRES :
1. Le code DOIT contenir :
   - CSS dans une balise <style>
   - HTML dans le <body>
   - JavaScript dans une balise <script>
2. Style par défaut OBLIGATOIRE :
   - background-color: #ffffff
   - color: #000000
3. Au moins une fonction JavaScript
4. Un CDN de cdnjs.cloudflare.com

Régénère le code complet en respectant TOUTES ces contraintes.`;

            try {
                const newCode = await this.callAI(correctionPrompt);
                return await this.validateAndRetryGeneration(newCode, retryCount + 1);
            } catch (error) {
                this.log(`Erreur lors de la régénération: ${error.message}`, 'error');
                throw error;
            }
        }

        if (!validation.isValid) {
            // Si toujours invalide après les retries, on force les styles de base
            const correctedCode = this.ensureBaseStyles(code);
            this.log('Styles de base forcés sur le code.', 'warning');
            return correctedCode;
        }

        return code;
    }

    /**
     * Méthode pour forcer les styles de base si le code généré ne les contient pas.
     * @param {string} code - Le code généré par l'IA.
     * @returns {string} - Le code avec les styles forcés.
     */
    ensureBaseStyles(code) {
        // Vérifie si une balise style existe déjà
        const hasStyle = /<style[^>]*>[\s\S]*?<\/style>/i.test(code);
        const baseStyles = `
            <style>
                body {
                    background-color: #ffffff !important;
                    color: #000000 !important;
                    margin: 0;
                    padding: 20px;
                    font-family: Arial, sans-serif;
                }
                .game-container {
                    max-width: 800px;
                    margin: 0 auto;
                }
                /* Forcer les couleurs pour les éléments de texte communs */
                p, h1, h2, h3, h4, h5, h6, span, div {
                    color: #000000 !important;
                }
                /* Conserver les couleurs spécifiques pour les boutons et éléments d'interface */
                button, .btn, .button {
                    color: inherit;
                }
            </style>
        `;

        if (!hasStyle) {
            // Ajoute les styles dans le head
            code = code.replace('</head>', `${baseStyles}</head>`);
        } else {
            // Injecte les styles de base au début des styles existants
            code = code.replace(/<style[^>]*>/i, match => `${match}
                body {
                    background-color: #ffffff !important;
                    color: #000000 !important;
                }
                p, h1, h2, h3, h4, h5, h6, span, div {
                    color: #000000 !important;
                }
                button, .btn, .button {
                    color: inherit;
                }
            `);
        }

        return code;
    }


async retrySpecificMode(mode, name, cve, description, maxRetries = 3) {
    let retryCount = 0;
    while (retryCount < maxRetries) {
        this.log(`Tentative ${retryCount + 1}/${maxRetries} pour le mode ${mode}...`, 'info');
        
        try {
            const prompt = mode === 'analogy' 
                ? this.buildAnalogyPrompt(name, cve, description)
                : this.buildTechnicalPrompt(name, cve, description);
            
            let response = await this.callAI(prompt);
            response = await this.validateAndRetryGeneration(response);
            
            const validation = this.validateGameContent(response);
            if (validation.isValid) {
                this.log(`Mode ${mode} généré avec succès.`, 'success');
                return { isValid: true, code: response, prompt: prompt }; // AJOUTÉ
            }
        } catch (error) {
            this.log(`Erreur lors de la tentative ${retryCount + 1}: ${error.message}`, 'error');
        }
        
        retryCount++;
        await new Promise(resolve => setTimeout(resolve, this.retryDelay));
    }
    
    return { isValid: false, code: null, prompt: null }; // AJOUTÉ
}

    /**
     * Méthode pour régénérer un jeu existant en redemandant à l'IA.
     * @param {string} vulnId - L'ID de la vulnérabilité.
     * @param {string} mode - Le mode à régénérer ('analogy' ou 'technical').
     */
    async reloadGame(vulnId, mode) {
        const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
        const vulnIndex = vulnerabilities.findIndex(v => v.id === vulnId.toString());
        if (vulnIndex === -1) {
            this.showNotification('Vulnérabilité non trouvée.', 'danger');
            return;
        }

        const vuln = vulnerabilities[vulnIndex];
        const currentPrompt = mode === 'analogy' ? vuln.analogyPrompt : vuln.technicalPrompt;
        const promptType = mode === 'analogy' ? 'analogie' : 'technique';

        // Demander à l'utilisateur de confirmer ou de modifier le prompt
        const userPrompt = prompt(`Veuillez entrer le prompt pour régénérer le jeu (${promptType}) :`, currentPrompt);

        if (userPrompt === null) {
            // L'utilisateur a annulé
            return;
        }

        if (userPrompt.trim() === '') {
            this.showNotification('Le prompt ne peut pas être vide.', 'warning');
            return;
        }

        // Mettre à jour le prompt dans l'objet vulnérabilité
        vulnerabilities[vulnIndex][`${mode}Prompt`] = userPrompt;
        this.storage.setItem('vulnerabilities', JSON.stringify(vulnerabilities));

        // Désactiver le bouton de génération pour éviter les conflits
        const generateButton = document.querySelector('.btn-primary');
        if (generateButton) {
            generateButton.disabled = true;
        }

        try {
            this.log(`Début de la régénération du mode ${promptType}...`, 'info');

            // Appeler l'IA avec le nouveau prompt
            const newCode = await this.callAI(userPrompt);

            // Valider le nouveau code
            const validatedCode = await this.validateAndRetryGeneration(newCode);
            const validation = this.validateGameContent(validatedCode);

            if (validation.isValid) {
                this.log(`Mode ${promptType} régénéré et validé.`, 'success');
                vulnerabilities[vulnIndex][`${mode}Code`] = validatedCode;
                this.storage.setItem('vulnerabilities', JSON.stringify(vulnerabilities));

                // Rafraîchir l'iframe avec le nouveau contenu
                const modal = document.querySelector('.modal');
                if (modal) {
                    const iframe = modal.querySelector('iframe');
                    if (iframe) {
                        const wrappedContent = `
                            <!DOCTYPE html>
                            <html>
                            <head>
                                <meta charset="UTF-8">
                                <style>
                                    /* Style de base forcé */
                                    html, body {
                                        background-color: #ffffff !important;
                                        color: #000000 !important;
                                        margin: 0 !important;
                                        padding: 20px !important;
                                        min-height: 100vh !important;
                                        font-family: Arial, sans-serif !important;
                                    }
                                    /* Forcer les couleurs pour les éléments de texte communs */
                                    p, h1, h2, h3, h4, h5, h6, span, div {
                                        color: #000000 !important;
                                    }
                                    /* Conserver les couleurs spécifiques pour les boutons et éléments d'interface */
                                    button, .btn, .button {
                                        color: inherit;
                                    }
                                </style>
                                ${validatedCode.match(/<style[^>]*>[\s\S]*?<\/style>/gi) || ''}
                            </head>
                            <body>
                                ${validatedCode.match(/<body[^>]*>([\s\S]*?)<\/body>/i)?.[1] || validatedCode}
                                ${validatedCode.match(/<script[^>]*>[\s\S]*?<\/script>/gi) || ''}
                            </body>
                            </html>`;

                        iframe.srcdoc = DOMPurify.sanitize(validatedCode);
                    }
                }

                this.showNotification(`Mode ${promptType} régénéré avec succès.`, 'success');
            } else {
                this.log(`Mode ${promptType} invalide après régénération.`, 'error');
                this.showNotification(`La régénération du mode ${promptType} a échoué.`, 'danger');
            }

        } catch (error) {
            this.log(`Erreur lors de la régénération du mode ${promptType}: ${error.message}`, 'error');
            this.showNotification(`Erreur lors de la régénération du mode ${promptType}: ${error.message}`, 'danger');
        } finally {
            // Réactiver le bouton de génération
            if (generateButton) {
                generateButton.disabled = false;
            }
        }
    }
        
        // Modification de l'initialisation de l'application
        static initialize() {
            window.addEventListener('DOMContentLoaded', () => {
                window.app = new VulnLearnerApp();
                
                // Vérifier et reprendre la génération après l'initialisation complète
                const generationInProgress = window.localStorage.getItem('generationInProgress');
                if (generationInProgress) {
                    console.log('Génération en cours détectée, tentative de reprise...');
                    window.app.resumeGeneration().catch(error => {
                        console.error('Erreur lors de la reprise de la génération:', error);
                        window.app.showNotification('Erreur lors de la reprise de la génération', 'danger');
                    });
                }
            });
        }
        
    async callAI(prompt) {
        try {
            this.log('Envoi de la requête à l\'API...', 'info');
            const response = await this.apiManager.callAPI(prompt);
            this.log('Réponse reçue de l\'API', 'success');
            return response;
        } catch (error) {
            this.log(`Erreur API: ${error.message}`, 'error');
            throw error;
        }
    }
    
    loadState() {
        // Charger la configuration IA
        const savedConfig = JSON.parse(this.storage.getItem('aiConfig')) || this.getDefaultConfig();
        const savedTab = this.storage.getItem('currentTab') || 'création';
        const savedFormData = JSON.parse(this.storage.getItem('formData')) || {
            name: '',
            cve: '',
            description: ''
        };

        this.state = {
            aiConfig: savedConfig,
            currentTab: savedTab,
            formData: savedFormData
        };

        // Mettre à jour l'API Manager avec la configuration chargée
        this.apiManager.updateConfig(savedConfig);
        
        // Mettre à jour l'interface
        this.updateAIBadge();
        this.loadCurrentTab();
    }

    initializeState() {
        // Charger l'état sauvegardé ou utiliser les valeurs par défaut
        this.loadState();
        
        // Configuration initiale si nécessaire
        if (!this.storage.getItem('vulnerabilities')) {
            this.storage.setItem('vulnerabilities', JSON.stringify([]));
        }
        if (!this.storage.getItem('userProgress')) {
            this.storage.setItem('userProgress', JSON.stringify({
                completedGames: [],
                totalScore: 0
            }));
        }
    }
        
    }
    
    

    // Initialisation de l'application
    VulnLearnerApp.initialize();
    
</script>
</body>
</html>
