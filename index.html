<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>VulnLearner - Apprentissage Ludique</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --accent: #3b82f6;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
            --card-bg: rgba(30, 41, 59, 0.5);
        }
        body {
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: 'Inter', system-ui, sans-serif;
            min-height: 100vh;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        .navbar {
            background: var(--bg-secondary);
            padding: 1rem 2rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(45deg, var(--accent), var(--success));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        .card {
            background: var(--card-bg);
            border-radius: 1rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s;
        }
        .card:hover {
            transform: translateY(-2px);
        }
        .input {
            width: 100%;
            padding: 0.75rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
            color: var(--text-primary);
            margin-bottom: 1rem;
            font-size: 1rem;
        }
        
        .input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1rem;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        .btn-primary {
            background: var(--accent);
            color: white;
        }
        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .btn-success { background: var(--success); color: white; }
        .btn-warning { background: var(--warning); color: white; }
        .btn-danger { background: var(--danger); color: white; }
        .btn:hover {
            transform: translateY(-1px);
            filter: brightness(110%);
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
        }
        .tab-group {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
        }
        .tab {
            padding: 0.5rem 1rem;
            cursor: pointer;
            border-radius: 0.5rem;
            transition: all 0.2s;
            color: var(--text-secondary);
        }
        .tab.active {
            background: var(--accent);
            color: white;
        }
        .terminal {
            background: #1a1a1a;
            padding: 1rem;
            border-radius: 0.5rem;
            font-family: 'Fira Code', monospace;
            line-height: 1.4;
            margin: 1rem 0;
            max-height: 400px;
            overflow-y: auto;
        }
        .terminal-line {
            display: flex;
            gap: 1rem;
            padding: 0.25rem 0;
        }
        .terminal-prompt {
            color: var(--success);
        }
        .terminal-output {
            color: var(--text-secondary);
            white-space: pre-wrap;
        }
        .badge {
            padding: 0.25rem 0.5rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 500;
        }
        .badge-blue { background: rgba(59, 130, 246, 0.1); color: var(--accent); }
        .badge-green { background: rgba(34, 197, 94, 0.1); color: var(--success); }
        .badge-warning { background: rgba(245, 158, 11, 0.1); color: var(--warning); }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-in {
            animation: fadeIn 0.3s ease-out;
        }
        .flex {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        /* Modal styles */
        .modal-content {
            width: 90%; /* Responsive width */
            max-width: 800px; /* Limit max width for better readability */
            height: 90vh; /* Viewport height */
            max-height: 600px; /* Limit height */
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background: var(--bg-secondary);
            padding: 1rem;
            border-radius: 1rem;
        }
        
        /* Game iframe container styles */
        .game-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }
        
        .game-container iframe {
            width: 100%; /* Full width within the container */
            height: 100%;
            border: none;
            border-radius: 0.5rem;
    background-color: var(--bg-secondary);
        }
        
        .progress-container {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }


/* General Styling */
body {
    background: #1a1d25; /* Softer background */
    color: #f0f2f5; /* Softer text color for readability */
    font-family: 'Inter', sans-serif;
}

.container {
    max-width: 800px; /* More centralized, comfortable width */
    margin: 0 auto;
    padding: 2rem;
}

/* Card Styling */
.card {
    background: #242833; /* Softer, more neutral card background */
    border-radius: 8px;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

/* Button Styling */
.btn {
    padding: 0.75rem 1.5rem;
    border: none;
    border-radius: 8px; /* Rounded corners */
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s;
    font-size: 1rem;
}

.btn-primary {
    background: #3b82f6; /* Softer blue */
    color: white;
}

.btn-primary:hover {
    background: #2563eb; /* Darker blue on hover */
}

.btn-danger {
    background: #ef4444; /* Softer red */
    color: white;
}

.btn-danger:hover {
    background: #dc2626; /* Darker red on hover */
}

/* Progress Bar Styling */
.progress-container {
    background: #3a3f47;
    border-radius: 5px;
    overflow: hidden;
    height: 12px;
    margin: 0.5rem 0;
}

.progress-container progress {
    background-color: #3b82f6; /* Use primary color for consistency */
    height: 100%;
}

/* Textarea for Description */
textarea.input {
    resize: vertical; /* Allow vertical resizing only */
    min-height: 100px; /* Ensure sufficient height for readability */
}

/* Appliquer ce style globalement à tous les champs de texte et zones de texte */
input[type="text"],
textarea {
    width: 100%;
    padding: 10px;
    background-color: #ffffff; /* Fond clair */
    color: #333333; /* Couleur du texte */
    border: 1px solid #d1d5db; /* Bordure gris clair */
    border-radius: 4px;
    font-size: 1rem;
    margin-bottom: 15px;
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
}

input[type="text"]:focus,
textarea:focus {
    border-color: #3b82f6; /* Couleur d'accentuation */
    box-shadow: 0 0 5px rgba(59, 130, 246, 0.5); /* Ombre légère sur focus */
    outline: none;
}

input[type="text"],
textarea {
    width: 100%;
    padding: 10px;
    background-color: var(--bg-secondary); /* Couleur de fond sombre */
    color: var(--text-primary); /* Couleur de texte clair */
    border: 1px solid rgba(255, 255, 255, 0.1); /* Bordure discrète */
    border-radius: 4px;
    font-size: 1rem;
    margin-bottom: 15px;
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
}

input[type="text"]:focus,
textarea:focus {
    border-color: var(--accent); /* Couleur d'accentuation */
    box-shadow: 0 0 5px rgba(59, 130, 246, 0.5); /* Ombre légère sur focus */
    outline: none;
}

textarea {
    width: 100%;
    padding: 10px;
    background-color: var(--bg-secondary);
    color: var(--text-primary);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    font-size: 1rem;
    margin-bottom: 15px;
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
    height: calc(30vh - 10px); /* Ajuste cette valeur pour contrôler la hauteur */
}

textarea:focus {
    border-color: var(--accent);
    box-shadow: 0 0 5px rgba(59, 130, 246, 0.5);
    outline: none;
}

.modal-content {
    max-height: 80vh; /* Limite la hauteur de la modal */
    overflow-y: auto; /* Permet le défilement vertical */
    padding: 1rem;
}

    </style>
</head>
<body>
    <nav class="navbar">
        <div class="logo">VulnLearner</div>
        <div class="flex">
            <button class="btn btn-secondary" id="ai-config-btn">
                <span class="badge badge-warning">IA: Non configurée</span>
            </button>
            <span class="badge badge-blue">Mode Apprentissage</span>
            <button class="btn btn-secondary">Documentation</button>
        </div>
    </nav>
    <div class="container">
        <!-- Tab Navigation -->
        <div class="tab-group">
            <div class="tab" onclick="app.setTab('création')">Création</div>
            <div class="tab" onclick="app.setTab('bibliothèque')">Bibliothèque</div>
            <div class="tab" onclick="app.setTab('progression')">Progression</div>
        </div>
    
        <!-- Tab Content Area -->
        <div id="tab-content"></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.10/purify.min.js"></script>
    <script>
class VulnLearnerApp {
    constructor() {
        this.storage = window.localStorage;
        this.initializeModels();
        this.initializeState();
        this.initializeStorage();
        this.initializeEventListeners();
        this.loadCurrentTab();
        this.updateAIBadge();
        this.addUsageStyles();
    }
    setTab(tabName) {
        this.state.currentTab = tabName;
        this.storage.setItem('currentTab', tabName);
        this.loadCurrentTab();
    }
    initializeModels() {
        this.AI_MODELS = {
            claude: {
                models: {
                    'claude-3-opus-20240229': { maxTokens: 200000, costPer1kTokens: { input: 0.015, output: 0.075 }, description: 'Plus puissant et précis, meilleur raisonnement' },
                    'claude-3-sonnet-20240229': { maxTokens: 200000, costPer1kTokens: { input: 0.003, output: 0.015 }, description: 'Excellent rapport qualité/prix' },
                    'claude-2.1': { maxTokens: 100000, costPer1kTokens: { input: 0.008, output: 0.024 }, description: 'Modèle stable et éprouvé' },
                    'claude-instant-1.2': { maxTokens: 100000, costPer1kTokens: { input: 0.0008, output: 0.0024 }, description: 'Rapide et économique' }
                }
            },
            openai: {
                models: {
                    'gpt-4': { maxTokens: 8192, costPer1kTokens: { input: 0.03, output: 0.06 }, description: 'Plus précis, meilleur pour les tâches complexes' },
                    'gpt-4-turbo-preview': { maxTokens: 128000, costPer1kTokens: { input: 0.01, output: 0.03 }, description: 'Version preview de GPT-4, plus rapide' },
                    'gpt-3.5-turbo': { maxTokens: 4096, costPer1kTokens: { input: 0.0015, output: 0.002 }, description: 'Bon rapport qualité/prix, rapide' },
                    'gpt-3.5-turbo-16k': { maxTokens: 16384, costPer1kTokens: { input: 0.003, output: 0.004 }, description: 'GPT-3.5 avec contexte étendu' }
                }
            }
        };
    }
    getDefaultConfig() {
        if (!this.AI_MODELS || !this.AI_MODELS.claude || !this.AI_MODELS.openai) {
            return {
                provider: 'none',
                apiKey: '',
                endpoint: '',
                maxCost: 0,
                retryDelay: 1000,
                maxRetries: 3,
                enabledModels: { claude: [], openai: [] },
                modelOrder: { claude: [], openai: [] },
                preferredModel: ''
            };
        }
        return {
            provider: 'none',
            apiKey: '',
            endpoint: '',
            maxCost: 0,
            retryDelay: 1000,
            maxRetries: 3,
            enabledModels: {
                claude: Object.keys(this.AI_MODELS.claude.models).slice(0, 2),
                openai: Object.keys(this.AI_MODELS.openai.models).slice(0, 2)
            },
            modelOrder: {
                claude: Object.keys(this.AI_MODELS.claude.models),
                openai: Object.keys(this.AI_MODELS.openai.models)
            },
            preferredModel: ''
        };
    }
    initializeState() {
        var defaultConfig = this.getDefaultConfig();
        var savedConfig = JSON.parse(this.storage.getItem('aiConfig')) || {};
        this.state = {
            currentTab: this.storage.getItem('currentTab') || 'création',
            formData: JSON.parse(this.storage.getItem('formData')) || { name: '', cve: '', description: '' },
            aiConfig: Object.assign({}, defaultConfig, savedConfig, {
                enabledModels: Object.assign({}, defaultConfig.enabledModels, savedConfig.enabledModels || {}),
                modelOrder: Object.assign({}, defaultConfig.modelOrder, savedConfig.modelOrder || {}),
                preferredModel: savedConfig.preferredModel || defaultConfig.preferredModel
            })
        };
        this.storage.setItem('aiConfig', JSON.stringify(this.state.aiConfig));
    }
    getUsageStatsHTML() {
        var stats = JSON.parse(this.storage.getItem('usageStats') || '{}');
        var provider = this.state.aiConfig.provider;
        if (provider === 'none' || !stats[provider]) {
            return '<p>Aucune statistique disponible</p>';
        }
        var usageRows = Object.entries(stats[provider]).map((entry) => {
            var model = entry[0];
            var data = entry[1];
            return '<div class="usage-row">' +
                '<div class="model-name">' + model + '</div>' +
                '<div class="usage-details">' +
                    '<span>Appels: ' + data.calls + '</span>' +
                    '<span>Tokens: ' + data.tokens.toLocaleString() + '</span>' +
                    '<span>Coût: $' + data.cost.toFixed(4) + '</span>' +
                '</div>' +
            '</div>';
        }).join('');
        return '<div class="usage-table">' + usageRows + '<div class="usage-total"><strong>Total: $' + this.calculateTotalCost(stats[provider]).toFixed(4) + '</strong></div></div>';
    }
    calculateTotalCost(providerStats) {
        return Object.values(providerStats).reduce((total, data) => total + (data.cost || 0), 0);
    }
    updateUsageStats(provider, model, inputTokens, outputTokens) {
        var stats = JSON.parse(this.storage.getItem('usageStats') || '{}');
        if (!stats[provider]) stats[provider] = {};
        if (!stats[provider][model]) {
            stats[provider][model] = { calls: 0, tokens: 0, cost: 0 };
        }
        var modelInfo = this.AI_MODELS[provider].models[model];
        var inputCost = (inputTokens / 1000) * modelInfo.costPer1kTokens.input;
        var outputCost = (outputTokens / 1000) * modelInfo.costPer1kTokens.output;
        stats[provider][model].calls += 1;
        stats[provider][model].tokens += (inputTokens + outputTokens);
        stats[provider][model].cost += (inputCost + outputCost);
        this.storage.setItem('usageStats', JSON.stringify(stats));
        this.updateUsageDisplay();
    }
    updateUsageDisplay() {
        var usageStats = document.getElementById('usage-stats');
        if (usageStats) {
            usageStats.innerHTML = this.getUsageStatsHTML();
        }
    }
    resetUsageStats() {
        if (confirm('Voulez-vous vraiment réinitialiser toutes les statistiques d\'utilisation ?')) {
            this.storage.setItem('usageStats', JSON.stringify({}));
            this.updateUsageDisplay();
            this.showNotification('Statistiques réinitialisées', 'success');
        }
    }
    addUsageStyles() {
        var styles = document.createElement('style');
        styles.textContent = `
            .usage-table { margin-top: 1rem; }
            .usage-row { display: flex; justify-content: space-between; padding: 0.5rem; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
            .usage-details { display: flex; gap: 1rem; }
            .usage-total { margin-top: 1rem; text-align: right; color: var(--accent); }
            .model-name { font-weight: 500; }
        `;
        document.head.appendChild(styles);
    }
    
    getLibraryContent() {
        const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
        console.log("Displaying vulnerabilities:", vulnerabilities);
    
        if (!vulnerabilities.length) {
            return '<div class="card animate-in"><h2>Bibliothèque vide</h2><p style="color: var(--text-secondary);">Créez votre première vulnérabilité dans l\'onglet Création.</p></div>';
        }
    
        return vulnerabilities.map((vuln) => {
            const cveBadge = vuln.cve ? `<span class="badge badge-blue">${vuln.cve}</span>` : '';
            return `
                <div class="card animate-in">
                    <div style="margin-bottom: 1rem;">
                        <h3 style="margin-bottom: 0.5rem;">${vuln.name}</h3>
                        ${cveBadge}
                    </div>
                    <p style="color: var(--text-secondary); margin-bottom: 1rem;">${vuln.description}</p>
                    <div class="flex">
                        <button class="btn btn-primary" onclick="app.showGame('${vuln.id}', 'analogy')">Mode Histoire</button>
                        <button class="btn btn-warning" onclick="app.showGame('${vuln.id}', 'technical')">Mode Technique</button>
                        <button class="btn btn-danger" onclick="app.deleteVulnerability('${vuln.id}')">Supprimer</button>
                    </div>
                </div>`;
        }).join('');
    }




loadCurrentTab() {
    const contentContainer = document.querySelector('#tab-content');
    contentContainer.innerHTML = '';

    let content;
    switch (this.state.currentTab) {
        case 'création':
            content = this.getCreationContent();
            break;
        case 'bibliothèque':
            content = this.getLibraryContent();
            break;
        case 'progression':
            content = this.getProgressionContent();
            break;
        default:
            content = '';
    }
    contentContainer.insertAdjacentHTML('beforeend', content);
    if (this.state.currentTab === 'création') {
        this.initializeFormListeners();
    }
}



    getProgressionContent() {
        var progress = JSON.parse(this.storage.getItem('userProgress'));
        var vulnerabilities = JSON.parse(this.storage.getItem('vulnerabilities'));
        return '<div class="card animate-in"><h2>Votre Progression</h2><div style="margin-top: 1rem;"><div class="flex" style="margin-bottom: 1rem;"><div><h3 style="color: var(--success);">' + progress.totalScore + '</h3><p style="color: var(--text-secondary);">Score total</p></div><div><h3 style="color: var(--accent);">' + progress.completedGames.length + '</h3><p style="color: var(--text-secondary);">Scénarios terminés</p></div><div><h3 style="color: var(--warning);">' + vulnerabilities.length + '</h3><p style="color: var(--text-secondary);">Vulnérabilités créées</p></div></div><h3 style="margin: 1rem 0;">Dernières activités</h3>' + this.getRecentActivities() + '</div></div>';
    }
    getRecentActivities() {
        var progress = JSON.parse(this.storage.getItem('userProgress'));
        if (!progress.completedGames.length) {
            return '<p style="color: var(--text-secondary);">Aucune activité pour le moment</p>';
        }
        return '<div class="terminal" style="background: var(--bg-secondary);">' + progress.completedGames.sort((a, b) => b.timestamp - a.timestamp).slice(0, 5).map((game) => '<div class="terminal-line"><span class="terminal-prompt">></span><span class="terminal-output">' + game.name + ' - Mode ' + game.mode + ' <span style="color: var(--success);">+' + game.score + ' pts</span></span></div>').join('') + '</div>';
    }



deleteVulnerability(id) {
    if (confirm('Êtes-vous sûr de vouloir supprimer cette vulnérabilité ?')) {
        // Get current vulnerabilities
        let vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
        
        // Log the vulnerabilities before deletion for debugging
        console.log("Vulnerabilities before deletion:", vulnerabilities);

        // Filter out the vulnerability to delete with type check on ID
        vulnerabilities = vulnerabilities.filter((vuln) => {
            console.log(`Comparing ${vuln.id} with ${id}`);
            return vuln.id.toString() !== id.toString();
        });

        // Log the updated vulnerabilities list after filtering
        console.log("Vulnerabilities after filtering:", vulnerabilities);

        // Update localStorage with the new list
        localStorage.setItem('vulnerabilities', JSON.stringify(vulnerabilities));

        // Verify if the vulnerability was removed successfully
        const updatedVulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities'));
        console.log("Vulnerabilities in storage after deletion:", updatedVulnerabilities);

        // Show notification
        this.showNotification('Vulnérabilité supprimée', 'success');
        
        // Refresh the UI to reflect the updated vulnerabilities
        this.loadCurrentTab();
    }
}


async startGame(vulnId, mode) {
    const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities'));
    const vuln = vulnerabilities.find(v => v.id === vulnId);
    if (!vuln) return;

    // Demande à l'IA de générer le code index.html pour le jeu
    const gameContent = await this.callAI(this.buildGamePrompt(vuln.name, vuln.cve, mode));

    // Extraire le code HTML, CSS, et JS
    const codeMatch = gameContent.match(/```html([\s\S]*?)```/);
    if (codeMatch && codeMatch[1]) {
        const codeToInject = codeMatch[1].trim();

        // Créer la modal pour afficher le jeu
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
            <div class="modal-content card">
                <h2>${vuln.name} - ${mode === 'analogy' ? 'Mode Histoire' : 'Mode Technique'}</h2>
                <div class="game-container">
                    <iframe sandbox="allow-scripts allow-same-origin" width="100%" height="100%" frameborder="0"></iframe>
                </div>
                <div class="flex" style="margin-top: 1rem;">
                    <button class="btn btn-danger" onclick="this.closest('.modal').remove()">Fermer</button>
                </div>
            </div>
        `;

        // Ajouter la modal au document
        document.body.appendChild(modal);

        // Injecter le code HTML directement dans l'iframe
        const iframe = modal.querySelector('iframe');
        iframe.srcdoc = codeToInject;  // Injecter le code extrait
    } else {
        this.showNotification("Le code du jeu n'a pas pu être extrait.", 'danger');
    }
}

// Méthode pour construire le prompt pour demander le code à l'IA
buildGamePrompt(name, cve, mode) {
    return `Fournis uniquement le code HTML/CSS/JavaScript complet pour un jeu interactif qui explique la vulnérabilité ${name} (CVE: ${cve}) dans le mode ${mode}. Ne mets pas de texte supplémentaire, juste le code.`;
}



    renderGameIframe(game, mode) {
        if (mode === 'analogy' || mode === 'technical') {
            if (typeof game === 'object' && game.error) {
                return '<div class="step"><p style="color: var(--danger);">' + game.error + '</p></div>';
            }
            const simulationHTML = `
                <!DOCTYPE html>
                <html lang="fr">
                <head>
                    <meta charset="UTF-8">
                    <title>Simulation</title>
                    <style>
                        body { margin: 0; padding: 0; font-family: 'Inter', system-ui, sans-serif; background-color: #ffffff; color: #000000; }
                        .container { width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1rem; }
                        h1, h2, h3, p { text-align: center; }
                    </style>
                </head>
                <body>
                    <div class="container">` + game + `</div>
                </body>
                </html>`;
            return `<iframe srcdoc="${DOMPurify.sanitize(simulationHTML)}" sandbox="allow-scripts" width="100%" height="600px" frameborder="0"></iframe>`;
        }
    }
    initializeStorage() {
        if (!this.storage.getItem('vulnerabilities')) {
            this.storage.setItem('vulnerabilities', JSON.stringify([]));
        }
        if (!this.storage.getItem('userProgress')) {
            this.storage.setItem('userProgress', JSON.stringify({ completedGames: [], totalScore: 0 }));
        }
        if (!this.storage.getItem('formData')) {
            this.storage.setItem('formData', JSON.stringify({ name: '', cve: '', description: '' }));
        }
    }
    updateAIBadge() {
        var badge = document.querySelector('#ai-config-btn .badge');
        if (this.state.aiConfig.provider !== 'none') {
            badge.className = 'badge badge-blue';
            badge.textContent = 'IA: ' + this.state.aiConfig.provider;
        } else {
            badge.className = 'badge badge-warning';
            badge.textContent = 'IA: Non configurée';
        }
    }
    initializeEventListeners() {
        var tabs = document.querySelectorAll('.tab');
        for (var i = 0; i < tabs.length; i++) {
            tabs[i].addEventListener('click', (e) => {
                var allTabs = document.querySelectorAll('.tab');
                for (var j = 0; j < allTabs.length; j++) {
                    allTabs[j].classList.remove('active');
                }
                e.target.classList.add('active');
                this.state.currentTab = e.target.textContent.toLowerCase();
                this.storage.setItem('currentTab', this.state.currentTab);
                this.loadCurrentTab();
            });
        }
        var primaryButton = document.querySelector('.btn-primary');
        if (primaryButton) {
            primaryButton.addEventListener('click', () => {
                this.generateVulnerability();
            });
        }
    }

    initializeFormListeners() {
        const nameInput = document.querySelector('input[placeholder="Nom de la vulnérabilité"]');
        const cveInput = document.querySelector('input[placeholder="Identifiant CVE (optionnel)"]');
        const descTextarea = document.querySelector('textarea[placeholder="Description détaillée"]');
        
        if (!nameInput || !cveInput || !descTextarea) {
            console.warn("Form elements not found. Skipping initialization.");
            return;
        }
    
        nameInput.value = this.state.formData.name;
        cveInput.value = this.state.formData.cve;
        descTextarea.value = this.state.formData.description;
    
        const updateStorage = () => {
            this.state.formData = {
                name: nameInput.value,
                cve: cveInput.value,
                description: descTextarea.value
            };
            this.storage.setItem('formData', JSON.stringify(this.state.formData));
        };
    
        nameInput.addEventListener('input', updateStorage);
        cveInput.addEventListener('input', updateStorage);
        descTextarea.addEventListener('input', updateStorage);
    }


loadCurrentTab() {
    const contentContainer = document.querySelector('#tab-content');

    // Clear only the tab content area
    contentContainer.innerHTML = '';

    // Load content based on the current tab
    let content;
    switch (this.state.currentTab) {
        case 'création':
            content = `
                <div class="card animate-in">
                    <h2>Nouvelle Vulnérabilité</h2>
                    <div class="grid" style="margin-top: 1rem;">
                        <div>
                            <input type="text" placeholder="Nom de la vulnérabilité" value="${this.state.formData.name}">
                            <input type="text" placeholder="Identifiant CVE (optionnel)" value="${this.state.formData.cve}">
                            <textarea rows="4" placeholder="Description détaillée">${this.state.formData.description}</textarea>
                            <button class="btn btn-primary" onclick="app.generateVulnerability()">Générer les Simulations</button>
                        </div>
                        <div class="terminal">
                            <div class="terminal-line">
                                <span class="terminal-prompt">$</span>
                                <span class="terminal-output">En attente de génération...</span>
                            </div>
                        </div>
                    </div>
                    <div id="analogyContainer" class="card animate-in" style="margin-top: 1rem; display: none;">
                        <h3>Scénario Analogique</h3>
                        <div class="terminal"></div>
                    </div>
                    <div id="technicalContainer" class="card animate-in" style="margin-top: 1rem; display: none;">
                        <h3>Simulation Technique</h3>
                        <div class="terminal"></div>
                    </div>
                </div>`;
            break;

        case 'bibliothèque':
            content = this.getLibraryContent();
            break;

        case 'progression':
            content = this.getProgressionContent();
            break;

        default:
            content = '';
    }

    // Insert the content only once into #tab-content
    contentContainer.insertAdjacentHTML('beforeend', content);

    // Initialize form listeners only for the "création" tab
    if (this.state.currentTab === 'création') {
        this.initializeFormListeners();
    }
}




async generateVulnerability() {
    const terminal = document.querySelector('.terminal');
    terminal.innerHTML = ''; // Clear previous content

    const { name, cve, description } = this.state.formData;
    if (!name || !description) {
        this.showNotification('Veuillez remplir les champs requis', 'danger');
        return;
    }

    try {
        // Generate analogy and technical responses
        this.appendToTerminal(terminal, 'Génération du scénario analogique...', 'info');
        const analogyResponse = await this.callAI(this.buildAnalogyPrompt(name, cve, description));
        this.appendToTerminal(terminal, 'Génération du scénario technique...', 'info');
        const technicalResponse = await this.callAI(this.buildTechnicalPrompt(name, cve, description));

        const vulnerability = {
            id: Date.now().toString(), // Ensure ID is a string for consistency
            name,
            cve,
            description,
            analogyCode: analogyResponse,
            technicalCode: technicalResponse,
            created: new Date().toISOString()
        };

        // Save vulnerability
        const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
        vulnerabilities.push(vulnerability);
        localStorage.setItem('vulnerabilities', JSON.stringify(vulnerabilities));

        this.showNotification('Vulnérabilité créée!', 'success');
        this.loadCurrentTab();

    } catch (error) {
        this.appendToTerminal(terminal, 'Erreur: ' + error.message, 'danger');
        this.showNotification(error.message, 'danger');
    }
}






appendToTerminal(terminal, text, type) {
    const line = document.createElement('div');
    line.className = 'terminal-line';
    line.innerHTML = `<span class="terminal-prompt">$</span><span class="terminal-output ${type}">${text}</span>`;
    terminal.appendChild(line);
    terminal.scrollTop = terminal.scrollHeight;
}

    showNotification(message, type) {
        var notification = document.createElement('div');
        notification.className = 'card animate-in';
        notification.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 1000; background: var(--' + type + '); padding: 1rem; color: ' + (type === 'danger' || type === 'warning' ? 'white' : 'black') + '; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);';
        notification.textContent = message;
        document.body.appendChild(notification);
        setTimeout(() => {
            notification.remove();
        }, 3000);
    }
    completeGame(vulnId, mode) {
        var vulnerabilities = JSON.parse(this.storage.getItem('vulnerabilities'));
        var vuln = vulnerabilities.find((v) => v.id === vulnId);
        if (!vuln) return;
        var progress = JSON.parse(this.storage.getItem('userProgress'));
        var score = mode === 'analogy' ? 10 : 20;
        progress.completedGames.push({ id: vulnId, name: vuln.name, mode: mode, score: score, timestamp: Date.now() });
        progress.totalScore += score;
        this.storage.setItem('userProgress', JSON.stringify(progress));
        this.showNotification('+' + score + ' points gagnés !', 'success');
        document.querySelector('.modal').remove();
        this.loadCurrentTab();
    }
    generateModelConfigHTML() {
        var provider = this.state.aiConfig.provider;
        if (provider === 'none') return '';
        
        if (!this.AI_MODELS || !this.AI_MODELS[provider] || !this.AI_MODELS[provider].models) {
            console.error("Configuration des modèles non disponible pour", provider);
            return '<div class="error">Configuration des modèles non disponible</div>';
        }
        
        var models = this.AI_MODELS[provider].models;
        var enabledModels = this.state.aiConfig.enabledModels[provider] || [];
        var modelOrder = this.state.aiConfig.modelOrder[provider] || Object.keys(models);
        
        var modelItems = modelOrder.map((modelId) => {
            var isChecked = enabledModels.includes(modelId) ? 'checked' : '';
            return '<div class="sortable-item" draggable="true" data-model="' + modelId + '">' +
                '<span class="handle">↕️</span>' +
                '<div class="model-info">' +
                    '<div class="model-name">' + modelId + '</div>' +
                    '<div class="model-description">' + models[modelId].description + '</div>' +
                    '<div class="model-specs">' +
                        'Max tokens: ' + models[modelId].maxTokens.toLocaleString() + ' | ' +
                        'Input: $' + models[modelId].costPer1kTokens.input + '/1k tokens | ' +
                        'Output: $' + models[modelId].costPer1kTokens.output + '/1k tokens' +
                    '</div>' +
                '</div>' +
                '<label class="toggle">' +
                    '<input type="checkbox" ' + isChecked + '>' +
                    '<span class="slider"></span>' +
                '</label>' +
            '</div>';
        }).join('');
        
        var modelSelector = '<div class="input-group">' +
            '<label>Modèle Préféré</label>' +
            '<select class="input" id="preferred-model">' +
                enabledModels.map((modelId) => {
                    var selected = this.state.aiConfig.preferredModel === modelId ? 'selected' : '';
                    return '<option value="' + modelId + '" ' + selected + '>' + modelId + '</option>';
                }).join('') +
            '</select>' +
        '</div>';
        
        var html = '<div class="model-preferences">' +
            '<h4>Configuration des modèles ' + provider + '</h4>' +
            modelSelector +
            '<div id="model-order" class="sortable-list">' +
                modelItems +
            '</div>' +
        '</div>';
        
        setTimeout(() => {
            this.updatePreferredModelOptions();
        }, 0);
        
        return html;
    }

    showAIConfig() {
        var modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = '<div class="modal-content card">' +
            '<h2>Configuration de l\'IA</h2>' +
            '<div class="grid" style="margin-top: 1rem;">' +
                '<div>' +
                    '<select class="input" id="ai-provider" onchange="app.updateProviderConfig(this.value)">' +
                        '<option value="none" ' + (this.state.aiConfig.provider === 'none' ? 'selected' : '') + '>' +
                            'Choisir un provider' +
                        '</option>' +
                        '<option value="claude" ' + (this.state.aiConfig.provider === 'claude' ? 'selected' : '') + '>' +
                            'Claude (Anthropic)' +
                        '</option>' +
                        '<option value="openai" ' + (this.state.aiConfig.provider === 'openai' ? 'selected' : '') + '>' +
                            'ChatGPT (OpenAI)' +
                        '</option>' +
                    '</select>' +
                    
                    '<div id="model-config" class="provider-config" style="margin-top: 1rem;">' +
                        this.generateModelConfigHTML() +
                    '</div>' +
                    
                    '<input type="password" class="input" id="ai-key" ' +
                        'placeholder="Clé API" value="' + this.state.aiConfig.apiKey + '">' +
                    '<input type="text" class="input" id="ai-endpoint" ' +
                        'placeholder="Endpoint (optionnel)" value="' + this.state.aiConfig.endpoint + '">' +
                    
                    '<div class="global-settings">' +
                        '<h4>Paramètres globaux</h4>' +
                        '<div class="input-group">' +
                            '<label>Budget maximum par requête (USD)</label>' +
                            '<input type="number" class="input" id="max-cost" ' +
                                'value="' + (this.state.aiConfig.maxCost || 0) + '" ' +
                                'step="0.01" min="0">' +
                        '</div>' +
                        '<div class="input-group">' +
                            '<label>Délai entre tentatives (ms)</label>' +
                            '<input type="number" class="input" id="retry-delay" ' +
                                'value="' + (this.state.aiConfig.retryDelay || 1000) + '" ' +
                                'min="500">' +
                        '</div>' +
                        '<div class="input-group">' +
                            '<label>Nombre maximum de tentatives</label>' +
                            '<input type="number" class="input" id="max-retries" ' +
                                'value="' + (this.state.aiConfig.maxRetries || 3) + '" ' +
                                'min="1" max="5">' +
                        '</div>' +
                    '</div>' +
                    
                    '<div class="usage-stats">' +
                        '<h4>Statistiques d\'utilisation</h4>' +
                        '<div id="usage-stats">' +
                            this.getUsageStatsHTML() +
                        '</div>' +
                    '</div>' +
                    
                    '<div class="flex" style="margin-top: 1rem;">' +
                        '<button class="btn btn-primary" onclick="app.saveAIConfig()">Sauvegarder</button>' +
                        '<button class="btn btn-secondary" onclick="app.testConnection()">Tester la connexion</button>' +
                        '<button class="btn btn-danger" onclick="this.closest(\'.modal\').remove()">Fermer</button>' +
                        
                        '<button class="btn btn-warning" onclick="app.resetUsageStats()">' +
                            'Réinitialiser les statistiques' +
                        '</button>' +
                    '</div>' +
                '</div>' +
            '</div>' +
        '</div>';
        
        document.body.appendChild(modal);
        this.initializeConfigHandlers();
    }
    updateProviderConfig(provider) {
        console.log('Provider updated to: ' + provider);

        this.state.aiConfig.provider = provider;

        if (provider === 'none') {
            this.state.aiConfig.apiKey = '';
            this.state.aiConfig.endpoint = '';
            this.state.aiConfig.enabledModels = { claude: [], openai: [] };
            this.state.aiConfig.modelOrder = { claude: [], openai: [] };
            this.state.aiConfig.preferredModel = '';
        } else {
            const providerModels = this.AI_MODELS[provider].models;
            this.state.aiConfig.enabledModels[provider] = Object.keys(providerModels).slice(0, 2);
            this.state.aiConfig.modelOrder[provider] = Object.keys(providerModels);
            this.state.aiConfig.preferredModel = this.state.aiConfig.enabledModels[provider][0] || '';
        }

        this.storage.setItem('aiConfig', JSON.stringify(this.state.aiConfig));

        const modelConfigDiv = document.getElementById('model-config');
        if (modelConfigDiv) {
            modelConfigDiv.innerHTML = this.generateModelConfigHTML();
            this.initializeModelConfigHandlers();
        }

        this.updateAIBadge();
        this.updateUsageDisplay();
        this.showNotification('AI provider configuration updated.', 'success');
    }
    initializeConfigHandlers() {
        // Set up event listeners for configuration elements here
        const checkboxes = document.querySelectorAll('.provider-config input[type="checkbox"]');
        for (let checkbox of checkboxes) {
            checkbox.addEventListener('change', (e) => {
                const modelId = e.target.closest('.sortable-item').getAttribute('data-model');
                const provider = this.state.aiConfig.provider;

                if (e.target.checked) {
                    this.state.aiConfig.enabledModels[provider].push(modelId);
                } else {
                    this.state.aiConfig.enabledModels[provider] = this.state.aiConfig.enabledModels[provider].filter((id) => id !== modelId);
                    
                    if (this.state.aiConfig.preferredModel === modelId) {
                        this.state.aiConfig.preferredModel = this.state.aiConfig.enabledModels[provider][0] || '';
                        const preferredModelSelect = document.getElementById('preferred-model');
                        if (preferredModelSelect) {
                            preferredModelSelect.value = this.state.aiConfig.preferredModel;
                        }
                    }
                }

                this.storage.setItem('aiConfig', JSON.stringify(this.state.aiConfig));
                this.updateUsageDisplay();
                this.updatePreferredModelOptions();
            });
        }

        const preferredModelSelect = document.getElementById('preferred-model');
        if (preferredModelSelect) {
            preferredModelSelect.addEventListener('change', (e) => {
                this.state.aiConfig.preferredModel = e.target.value;
                this.storage.setItem('aiConfig', JSON.stringify(this.state.aiConfig));
            });
        }
    }
    updatePreferredModelOptions() {
        const provider = this.state.aiConfig.provider;
        const enabledModels = this.getEnabledModels(provider);
        const preferredModelSelect = document.getElementById('preferred-model');
    
        if (!preferredModelSelect) return;
    
        const currentSelection = this.state.aiConfig.preferredModel;
    
        preferredModelSelect.innerHTML = '';
    
        enabledModels.forEach((modelId) => {
            const option = document.createElement('option');
            option.value = modelId;
            option.textContent = modelId;
            if (modelId === currentSelection) {
                option.selected = true;
            }
            preferredModelSelect.appendChild(option);
        });
    
        if (!enabledModels.includes(currentSelection)) {
            this.state.aiConfig.preferredModel = enabledModels[0] || '';
            this.storage.setItem('aiConfig', JSON.stringify(this.state.aiConfig));
            preferredModelSelect.value = this.state.aiConfig.preferredModel;
        }
    }
    getEnabledModels(provider) {
        // Check if `enabledModels` exists in the current state and contains the specified provider
        if (this.state && this.state.aiConfig && this.state.aiConfig.enabledModels) {
            return this.state.aiConfig.enabledModels[provider] || [];
        }
        return [];
    }

    updatePreferredModelOptions() {
        const provider = this.state.aiConfig.provider;
        const enabledModels = this.getEnabledModels(provider);
        const preferredModelSelect = document.getElementById('preferred-model');

        if (!preferredModelSelect) return;

        const currentSelection = this.state.aiConfig.preferredModel;

        preferredModelSelect.innerHTML = '';

        enabledModels.forEach((modelId) => {
            const option = document.createElement('option');
            option.value = modelId;
            option.textContent = modelId;
            if (modelId === currentSelection) {
                option.selected = true;
            }
            preferredModelSelect.appendChild(option);
        });

        if (!enabledModels.includes(currentSelection)) {
            this.state.aiConfig.preferredModel = enabledModels[0] || '';
            this.storage.setItem('aiConfig', JSON.stringify(this.state.aiConfig));
            preferredModelSelect.value = this.state.aiConfig.preferredModel;
        }
    }
    initializeModelConfigHandlers() {
        // Add event listeners to model configuration checkboxes
        const checkboxes = document.querySelectorAll('.provider-config input[type="checkbox"]');
        checkboxes.forEach((checkbox) => {
            checkbox.addEventListener('change', (e) => {
                const modelId = e.target.closest('.sortable-item').getAttribute('data-model');
                const provider = this.state.aiConfig.provider;

                if (e.target.checked) {
                    this.state.aiConfig.enabledModels[provider].push(modelId);
                } else {
                    this.state.aiConfig.enabledModels[provider] = this.state.aiConfig.enabledModels[provider].filter((id) => id !== modelId);

                    if (this.state.aiConfig.preferredModel === modelId) {
                        this.state.aiConfig.preferredModel = this.state.aiConfig.enabledModels[provider][0] || '';
                        const preferredModelSelect = document.getElementById('preferred-model');
                        if (preferredModelSelect) {
                            preferredModelSelect.value = this.state.aiConfig.preferredModel;
                        }
                    }
                }

                this.storage.setItem('aiConfig', JSON.stringify(this.state.aiConfig));
                this.updateUsageDisplay();
                this.updatePreferredModelOptions();
            });
        });

        // Event listener for preferred model selection
        const preferredModelSelect = document.getElementById('preferred-model');
        if (preferredModelSelect) {
            preferredModelSelect.addEventListener('change', (e) => {
                this.state.aiConfig.preferredModel = e.target.value;
                this.storage.setItem('aiConfig', JSON.stringify(this.state.aiConfig));
            });
        }
    }
    async testConnection() {
        try {
            this.showNotification('Testing connection...', 'info');
            
            const provider = document.getElementById('ai-provider').value;
            const apiKey = document.getElementById('ai-key').value;
            const endpoint = document.getElementById('ai-endpoint').value || 'https://api.anthropic.com/v1/messages';
            const preferredModel = document.getElementById('preferred-model').value;
    
            if (!apiKey) {
                throw new Error('API Key is missing. Please enter it in the configuration.');
            }
    
            let response;
            if (provider === 'claude') {
                response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: preferredModel,
                        messages: [{ role: 'user', content: 'Connection test' }],
                        max_tokens: 10
                    })
                });
            } else if (provider === 'openai') {
                response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: preferredModel,
                        messages: [{ role: 'user', content: 'Connection test' }],
                        temperature: 0.5,
                        max_tokens: 10
                    })
                });
            }
    
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Connection test failed: ${errorText}`);
            }
    
            const result = await response.json();
            if (result.choices || result.content) {
                this.showNotification('Connection successful!', 'success');
            } else {
                throw new Error('Unexpected response structure.');
            }
        } catch (error) {
            this.showNotification(`Connection test failed: ${error.message}`, 'danger');
            console.error('Connection test error:', error);
        }
    }

    async callAI(prompt) {
        // Ensure a provider is selected
        const provider = this.state.aiConfig.provider;
        if (provider === 'none') {
            throw new Error('Please configure an AI provider in the settings.');
        }
    
        try {
            // Route to the correct API based on the provider
            if (provider === 'claude') {
                return await this.callClaude(prompt);
            } else if (provider === 'openai') {
                return await this.callChatGPT(prompt);
            } else {
                throw new Error('Unsupported AI provider selected.');
            }
        } catch (error) {
            console.error('Error in callAI:', error);
            throw error;
        }
    }
    // Function to call the Claude API
    async callClaude(prompt) {
        const selectedModel = this.state.aiConfig.preferredModel;
        const apiKey = this.state.aiConfig.apiKey;
    
        // Check if API key is present
        if (!apiKey) {
            throw new Error('API Key for Claude is missing. Please configure it in the settings.');
        }
    
        const url = this.state.aiConfig.endpoint || 'https://api.anthropic.com/v1/messages';
    
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': apiKey, // Ensure the key is added here
                'anthropic-version': '2023-06-01',
                'anthropic-dangerous-direct-browser-access': 'true' 
            },
            body: JSON.stringify({
                model: selectedModel,
                messages: [{ role: 'user', content: prompt }],
                max_tokens: 4096
            })
        });
    
        if (!response.ok) {
            throw new Error(`Claude API Error: ${await response.text()}`);
        }
    
        const result = await response.json();
        return result.content[0].text.trim();
    }
    
    // Function to call the OpenAI API
    async callChatGPT(prompt) {
        const selectedModel = this.state.aiConfig.preferredModel;
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${this.state.aiConfig.apiKey}`
            },
            body: JSON.stringify({
                model: selectedModel,
                messages: [{ role: 'user', content: prompt }],
                temperature: 0.7
            })
        });
    
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.message || 'OpenAI API Error');
        }
    
        const data = await response.json();
        return data.choices[0].message.content;
    }
    saveAIConfig() {
        const provider = document.getElementById('ai-provider').value;
        const apiKey = document.getElementById('ai-key').value;
        const endpoint = document.getElementById('ai-endpoint').value;
        const preferredModel = document.getElementById('preferred-model') ? document.getElementById('preferred-model').value : '';
    
        this.state.aiConfig = {
            ...this.state.aiConfig,
            provider,
            apiKey,
            endpoint,
            preferredModel,
            maxCost: parseFloat(document.getElementById('max-cost').value) || 0,
            retryDelay: parseInt(document.getElementById('retry-delay').value) || 1000,
            maxRetries: parseInt(document.getElementById('max-retries').value) || 3
        };
    
        this.storage.setItem('aiConfig', JSON.stringify(this.state.aiConfig));
        document.querySelector('.modal').remove();
        this.showNotification('AI configuration saved successfully', 'success');
        this.updateAIBadge();
    }

buildAnalogyPrompt(name, cve, description) {
    return `
    Crée un jeu interactif en HTML/CSS/JavaScript pour expliquer de manière analogique la vulnérabilité suivante : ${description}.

    **Détails du jeu** :
    - Le jeu doit être simple et ludique, conçu sous forme d'analogie pour aider les utilisateurs à comprendre le concept de l'attaque sans entrer dans les détails techniques.
    - Utilise une métaphore : imagine une scène qui simule une "infiltration" ou une "attaque" de manière amusante, par exemple un agent secret qui tente de pénétrer un bâtiment sécurisé pour représenter l'injection de code.
    - Le joueur doit accomplir plusieurs actions pour "infiltrer" ou "désactiver" les défenses, en cliquant sur des éléments ou en choisissant les bonnes options.
    - Ajoute des feedbacks visuels pour chaque action (par exemple, des messages ou des animations) pour indiquer la progression.
    - La couleur de fond doit être #f5f5f5, avec une interface simple et claire, et un bouton "Continuer" pour chaque étape.

    À la fin du jeu, le joueur doit comprendre que la vulnérabilité ${name} représente une faiblesse que l'on peut exploiter en s'infiltrant de manière ciblée.
    Montre moi le code index.html sans commentaire ni ommission.
    `;
}

buildTechnicalPrompt(name, cve, description) {
    return `
    Crée un jeu interactif en HTML/CSS/JavaScript pour simuler techniquement une attaque sur la vulnérabilité suivante : ${description}.

    **Détails du jeu** :
    - Le jeu doit suivre un format de terminal où le joueur peut entrer des commandes ou cliquer pour exécuter des actions.
    - Chaque étape de l'attaque doit être représentée de manière réaliste, par exemple : "nmap scan" pour détecter les ports ouverts, "exploit avec SQLMap" pour injecter du code, etc.
    - Chaque étape doit inclure une description claire de l'action technique réalisée et fournir des retours visuels (par exemple, des lignes de commande et des résultats).
    - L'interface du terminal doit être sombre (fond #1a1d25) avec des couleurs vertes pour le texte des commandes (#39ff14) et des détails blancs pour les retours d’information.
    - Ajoute des boutons pour avancer dans le processus, chaque étape du jeu devant enseigner un concept technique particulier lié à cette vulnérabilité.

    Le joueur doit sortir de cette simulation avec une compréhension claire des étapes nécessaires pour exploiter cette vulnérabilité.
    Montre moi le code index.html sans commentaire ni ommission.
    `;
}



showGame(vulnId, mode) {
    const vulnerabilities = JSON.parse(localStorage.getItem('vulnerabilities')) || [];
    const vuln = vulnerabilities.find(v => v.id === vulnId.toString());
    if (!vuln) {
        this.showNotification('Vulnérabilité non trouvée.', 'danger');
        return;
    }

    const gameContent = mode === 'analogy' ? vuln.analogyCode : vuln.technicalCode;
    if (!gameContent) {
        this.showNotification('Le jeu sélectionné est manquant.', 'danger');
        return;
    }

    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
        <div class="modal-content card">
            <h2>${vuln.name} - ${mode === 'analogy' ? 'Mode Histoire' : 'Mode Technique'}</h2>
            <div class="game-container">
                <iframe srcdoc="${DOMPurify.sanitize(gameContent)}" sandbox="allow-scripts" width="100%" height="100%" frameborder="0"></iframe>
            </div>
            <button class="btn btn-danger" onclick="this.closest('.modal').remove()">Fermer</button>
        </div>
    `;
    document.body.appendChild(modal);
}



}


window.addEventListener('DOMContentLoaded', function() {
    window.app = new VulnLearnerApp();
    var aiConfigBtn = document.getElementById('ai-config-btn');
    if (aiConfigBtn) {
        aiConfigBtn.addEventListener('click', function() {
            app.showAIConfig();
        });
    }
});

    </script>
</body>
</html>
